

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="积极向上好青年">
  <meta name="keywords" content="">
  
    <meta name="description" content="前言结合所有的资料，和自己总结过的，再次总结面试八股文2021年1月23日 Java知识点基础知识数据类型8个基本数据类型，1位&#x3D;1bit，1字节&#x3D;8位  boolean 1bit byte 1字节 char 2字节，和C++不一样，可以存放中文 short 2字节 int 4字节 float 4字节 long 8字节 double 8字节  考点：隐式转换问题？ 1234">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 面试总结">
<meta property="og:url" content="http://zhangchaozc.cn/2021/01/23/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="积极向上好青年">
<meta property="og:description" content="前言结合所有的资料，和自己总结过的，再次总结面试八股文2021年1月23日 Java知识点基础知识数据类型8个基本数据类型，1位&#x3D;1bit，1字节&#x3D;8位  boolean 1bit byte 1字节 char 2字节，和C++不一样，可以存放中文 short 2字节 int 4字节 float 4字节 long 8字节 double 8字节  考点：隐式转换问题？ 1234">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22879930/1653113699585-956c4a95-7533-4155-af6d-627857bb96e4.jpeg#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u4c584645&margin=%5Bobject%20Object%5D&name=%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.jpg&originHeight=240&originWidth=324&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10021&status=done&style=none&taskId=ud8a64e37-7b2f-40c5-aafa-357082cf699&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113716377-ff4b2f97-973d-4397-85fe-6d1c3a8dcc90.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=344&id=u28201fb1&margin=%5Bobject%20Object%5D&name=Java%E5%BC%82%E5%B8%B8.png&originHeight=458&originWidth=718&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18102&status=done&style=none&taskId=ue789e32f-6f86-40cc-9436-a6dc429872b&title=&width=540">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113746757-e58f27a0-ad36-48e1-9184-8ab268658407.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=351&id=u3304566e&margin=%5Bobject%20Object%5D&name=%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB%E5%9B%BE.png&originHeight=426&originWidth=656&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103878&status=done&style=none&taskId=u1f19d581-46b3-4d60-85ff-bd39f293ef6&title=&width=541">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113791417-070661c7-ae97-47e0-9a08-462f4e24b0c9.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=320&id=u38341345&margin=%5Bobject%20Object%5D&name=HashMap%E7%A4%BA%E6%84%8F.png&originHeight=545&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23933&status=done&style=none&taskId=uecf6285d-6f65-4cb0-b427-775b6bb25eb&title=&width=423">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113827539-e5e71be3-3990-44e4-9462-e08f799582a0.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=217&id=u428b461c&margin=%5Bobject%20Object%5D&name=HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF.png&originHeight=258&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31569&status=done&style=none&taskId=u99523a7d-026d-43be-88d7-afcde6c85e2&title=&width=563">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113862092-a21f30c4-7b12-4447-ad14-035ec39d4c20.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=428&id=u1c333bcc&margin=%5Bobject%20Object%5D&name=JVM%E5%88%86%E5%8C%BA.png&originHeight=532&originWidth=394&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92558&status=done&style=none&taskId=udbfb3993-6bb3-4d9e-b258-fa1f66ea135&title=&width=317">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113912399-660782d2-105a-4cb4-b244-8fa383449ac6.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=251&id=u815e724e&margin=%5Bobject%20Object%5D&name=%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png&originHeight=310&originWidth=541&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14038&status=done&style=none&taskId=u64931d27-aea2-4c9b-b774-af8d49c4ade&title=&width=438">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113942503-5623a5fd-8302-438b-951d-fa38c923112f.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=180&id=u78bc141a&margin=%5Bobject%20Object%5D&name=%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png&originHeight=193&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42149&status=done&style=none&taskId=u9a2c5a61-decc-4dae-8dde-187deda45da&title=&width=518">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113973174-2c9f13c3-23f9-4a00-bb18-12019184d82c.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=195&id=ud09ec603&margin=%5Bobject%20Object%5D&name=%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png&originHeight=204&originWidth=545&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52753&status=done&style=none&taskId=u82ab9132-4fd6-4c11-a637-8d4253a0db0&title=&width=520">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113998961-cc1af0ad-e28f-46d6-be60-d6354ebb4079.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=192&id=u1991ef6d&margin=%5Bobject%20Object%5D&name=%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png&originHeight=206&originWidth=572&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82523&status=done&style=none&taskId=uce86a947-d793-4202-b0c2-d7ad2fc224a&title=&width=533">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114032580-70755351-90dc-43aa-8900-b39a533709f4.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=334&id=uc90cd887&margin=%5Bobject%20Object%5D&name=%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png&originHeight=387&originWidth=557&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102482&status=done&style=none&taskId=u39681df5-9a1d-49b2-84ff-d2cb1134def&title=&width=480">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114076721-36d58fdf-ef49-4525-b523-fc2219c8cb38.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=163&id=u5cfeabe9&margin=%5Bobject%20Object%5D&name=%E7%B1%BB%E5%8A%A0%E8%BD%BD.png&originHeight=186&originWidth=611&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88103&status=done&style=none&taskId=u1b1471e9-4020-4343-affe-3d346279637&title=&width=537">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114112463-2c43c070-8889-4d2f-9da3-c4ea52646bb2.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=337&id=u17c16c64&margin=%5Bobject%20Object%5D&name=%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png&originHeight=411&originWidth=367&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61258&status=done&style=none&taskId=u11e25f0e-1c9d-4816-ab48-0cf5d75cd15&title=&width=301">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114140327-4e5a8533-ee9b-40c9-ac30-177d45fed9de.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=281&id=uce695019&margin=%5Bobject%20Object%5D&name=Java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C.png&originHeight=314&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38242&status=done&style=none&taskId=u25dd4329-d63b-4cf1-9727-afe7f2e063e&title=&width=448">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114171600-a5f35965-7dac-42df-ae38-9f5764f02fb4.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=252&id=u833d636e&margin=%5Bobject%20Object%5D&name=%E8%AF%BB%E5%86%99%E9%94%81.png&originHeight=307&originWidth=690&originalType=binary&ratio=1&rotation=0&showTitle=false&size=70157&status=done&style=none&taskId=u2c22a96a-b18b-4c8b-beea-fd13e9b53bc&title=&width=567">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114215155-caf50e06-8c37-453a-888a-0bb77c47dd17.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=359&id=u7d084200&margin=%5Bobject%20Object%5D&name=springmvc%E6%B5%81%E7%A8%8B.png&originHeight=442&originWidth=689&originalType=binary&ratio=1&rotation=0&showTitle=false&size=264041&status=done&style=none&taskId=u3210f93e-39eb-475d-abd4-01270693107&title=&width=559">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114243554-f9f7626f-db8a-4d0b-bfcd-04b400553eb9.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=279&id=uf85ca9a2&margin=%5Bobject%20Object%5D&name=UDP%E6%8A%A5%E6%96%87.png&originHeight=306&originWidth=569&originalType=binary&ratio=1&rotation=0&showTitle=false&size=107210&status=done&style=none&taskId=uf92b58df-ff47-4006-89f6-fc4394f69ff&title=&width=518">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114268160-3e368838-c85c-4ebe-9de8-e7c47a46e586.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=419&id=ubaf30aef&margin=%5Bobject%20Object%5D&name=TCP%E6%8A%A5%E6%96%87.png&originHeight=493&originWidth=691&originalType=binary&ratio=1&rotation=0&showTitle=false&size=142509&status=done&style=none&taskId=u71475384-adb2-4f42-9cb1-b04531bbe01&title=&width=587">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114300903-efa4c68c-341c-4570-ad24-b66edc2f95db.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=301&id=u2c12b962&margin=%5Bobject%20Object%5D&name=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&originHeight=350&originWidth=614&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92312&status=done&style=none&taskId=uf96588ed-1c80-44b6-b6f0-ea2028b24ff&title=&width=528">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114336621-09b7e6d9-e5b3-4ce0-850e-e0e9a9bd854d.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=345&id=uddf4127a&margin=%5Bobject%20Object%5D&name=TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png&originHeight=377&originWidth=548&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116016&status=done&style=none&taskId=u1a0722de-40e9-48cd-bd3a-2d15bfcd8cc&title=&width=501">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114370101-e378b884-acd6-4ee9-9731-2a988d920af4.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=252&id=u3120333e&margin=%5Bobject%20Object%5D&name=TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png&originHeight=304&originWidth=742&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141108&status=done&style=none&taskId=u0203e10b-384b-4387-8c6a-ef64660f8fa&title=&width=614">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114396304-55df5c5b-95e7-439f-a41a-ca1cf4c35bc3.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=330&id=ufe93a412&margin=%5Bobject%20Object%5D&name=IP%E6%8A%A5%E6%96%87.png&originHeight=362&originWidth=655&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116864&status=done&style=none&taskId=u5e8f5d61-2699-4c24-81f9-ce34e702013&title=&width=598">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114423825-2c2f9280-d3dd-4046-9f57-3ac442e6cfa0.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc3a9dca0&margin=%5Bobject%20Object%5D&name=IP%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86.png&originHeight=281&originWidth=477&originalType=binary&ratio=1&rotation=0&showTitle=false&size=78409&status=done&style=none&taskId=u1da6eab9-b4cb-42a1-b13e-27ff4adb11e&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114463128-076d2156-0dc6-4090-aeb8-dd263206da1d.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=225&id=uadc8975a&margin=%5Bobject%20Object%5D&name=HTTP%E5%8D%8F%E8%AE%AE.png&originHeight=267&originWidth=609&originalType=binary&ratio=1&rotation=0&showTitle=false&size=94095&status=done&style=none&taskId=ufda36809-13eb-4a38-a721-bfcfd72a571&title=&width=513">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114490201-6b07d836-b781-4082-930d-a62c82094dac.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=220&id=u20a31796&margin=%5Bobject%20Object%5D&name=HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png&originHeight=259&originWidth=699&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20400&status=done&style=none&taskId=ueb65f523-9212-4e7b-9b18-95687cd3445&title=&width=594">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114530619-9e7e63f5-771d-4da2-b3d1-edea58b28b75.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uae3ea938&margin=%5Bobject%20Object%5D&name=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8A%A5%E6%96%87.png&originHeight=317&originWidth=372&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35943&status=done&style=none&taskId=uf1dc494c-5e3f-4847-b274-a04e82f625d&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114575142-e82ac0b6-9669-471c-8d85-dcc43506599c.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9462d5a4&margin=%5Bobject%20Object%5D&name=%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97.png&originHeight=281&originWidth=387&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24188&status=done&style=none&taskId=uc3fc554f-aa71-442a-97a3-fe6a1daa156&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114610141-6503e157-f429-41a5-bdf2-c0fd3c003202.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=290&id=ue7441120&margin=%5Bobject%20Object%5D&name=%E6%8E%92%E5%BA%8F.png&originHeight=325&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21345&status=done&style=none&taskId=ue046904c-c164-428a-be4d-97d41ba97ae&title=&width=494">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114642953-64d31867-6ed6-4dfd-ba9f-cf27be540869.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u51ab42a1&margin=%5Bobject%20Object%5D&name=B%E5%8A%A0%E6%A0%91.png&originHeight=191&originWidth=543&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12517&status=done&style=none&taskId=u32933ab8-8db8-4af9-b652-9105e5a983c&title=">
<meta property="article:published_time" content="2021-01-23T03:23:09.000Z">
<meta property="article:modified_time" content="2022-05-27T18:07:29.204Z">
<meta property="article:author" content="积极向上好青年">
<meta property="article:tag" content="校招">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22879930/1653113699585-956c4a95-7533-4155-af6d-627857bb96e4.jpeg#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u4c584645&margin=%5Bobject%20Object%5D&name=%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.jpg&originHeight=240&originWidth=324&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10021&status=done&style=none&taskId=ud8a64e37-7b2f-40c5-aafa-357082cf699&title=">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Java 面试总结 - 积极向上好青年</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"zhangchaozc.cn","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>积极向上好青年</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://s3.bmp.ovh/imgs/2022/05/24/2e670aaebc54c655.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java 面试总结"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-01-23 11:23" pubdate>
          2021年1月23日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          40k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          333 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java 面试总结</h1>
            
            <div class="markdown-body">
              
              <meta name="referrer" content="no-referrer" />

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>结合所有的资料，和自己总结过的，再次总结面试八股文<br>2021年1月23日</p>
<h1 id="Java知识点"><a href="#Java知识点" class="headerlink" title="Java知识点"></a>Java知识点</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>8个基本数据类型，1位&#x3D;1bit，1字节&#x3D;8位</p>
<ul>
<li>boolean 1bit</li>
<li>byte 1字节</li>
<li>char 2字节，和C++不一样，可以存放中文</li>
<li>short 2字节</li>
<li>int 4字节</li>
<li>float 4字节</li>
<li>long 8字节</li>
<li>double 8字节</li>
</ul>
<p><em>考点：隐式转换问题？</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.1</span>;  <span class="hljs-comment">//错误写法</span><br><span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.1f</span>; <span class="hljs-comment">//正确写法</span><br><span class="hljs-type">short</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>s1 += <span class="hljs-number">1</span>;        <span class="hljs-comment">//隐式转型，s1默认转化为int</span><br>s1++;           <span class="hljs-comment">//隐式转型，前两个都没问题</span><br>s1 = s1 + <span class="hljs-number">1</span>;    <span class="hljs-comment">//编译错误, s1 是 short，加完之后变成了 int</span><br></code></pre></td></tr></table></figure>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p><em>考点：switch支持的数据类型？</em><br>从Java 7开始，可以在switch条件判断语句中使用String对象，但是不支持long、float、double</p>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>基本数据类型都有自己的包装类<br><em>考点：Integer 内部的缓存机制？</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>System.out.println(m == n); <span class="hljs-comment">// true 而当 m &gt; 128时，两个对象就不相等了</span><br><span class="hljs-comment">// 为何会出现这种情况？看看源码</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; 就等于 <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 源码</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>    &#125;<br><span class="hljs-comment">// low~high取值：-128~127，在这个范围内取数组 IntegerCache，内存地址都一样，自然相等</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br>System.out.println(m == n); <span class="hljs-comment">// false new 出来的堆内存分配，肯定不相等啊</span><br>a.equals(b) <span class="hljs-comment">// true, 因为重写了方法，比较的是 int 数值</span><br></code></pre></td></tr></table></figure>
<p><em>考点：&#x3D;&#x3D; 和 equal 的区别？</em></p>
<ol>
<li>&#x3D;&#x3D; 用于比较基本数据类型是否相等，以及对象的内存地址是否相等</li>
<li>equal是Object类中的方法，默认也是比较对象的内存（this &#x3D;&#x3D; obj），但是该方法是可以重写的！例如String就重写了这个方法，改为依次比较每个字符是否相等（首先先判断长度是否相等，因为长度都不等，字符肯定不同）</li>
</ol>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><em>考点：final的基本用法？</em></p>
<ul>
<li><p>常量，初始化后不能修改</p>
</li>
<li><p>对于引用类型，引用关系不可变，但是被引用的对象本身是可以变的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-comment">// a 分配的地址是不能变的，但是地址里面的值可以变</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>声明方法不能被子类重写</p>
</li>
<li><p>声明类不允许被继承</p>
</li>
</ul>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><em>考点：String为什么不可变？哪里不可变？</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 源码上</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br><span class="hljs-comment">// final 数组，value[] 指向的内存是不能改变的。value[0]=&#x27;x&#x27;,这样是可以的，可以改变值，但是String并没有提供这种方法。所以不可变！</span><br></code></pre></td></tr></table></figure>
<p><em>考点：比较是否相等？String常量池？</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// 出来了几个对象？</span><br><span class="hljs-comment">// 两个。 &quot;a&quot; 在常量池中，a 在堆内存中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>System.out.println(b==c); <span class="hljs-comment">// 相等，都引用的常量池</span><br><span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;d&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;d&quot;</span>);<br>System.out.println(d == e); <span class="hljs-comment">// 不相等，堆内存咋可能相等？</span><br>d.equal(e); <span class="hljs-comment">// 相等啊，重写了 equal 方法</span><br>d.intern(); <span class="hljs-comment">// 动态把字符串加入到常量池中</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">当一个字符串调用intern()方法时，如果String Pool中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回String Pool中字符串的引用；否则，就会在 String Pool中添加一个新的字符串，并返回这个新字符串的引用</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p><em>考点：StringBuilder和StringBuffer，线程安全？</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 内部都是 char value[];都是内存可变的</span><br><span class="hljs-comment">// 增删改 StringBuffer 都加了synchronized 关键字，所以 StringBuffer 是线程安全的</span><br></code></pre></td></tr></table></figure>

<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><em>考点：初始化顺序？</em></p>
<ul>
<li>初始化顺序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;static A&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;&#123;&#125; A&quot;</span>);<br>    &#125;<br><br>    A() &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造函数 A&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;static B&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;&#123;&#125; B&quot;</span>);<br>    &#125;<br><br>    B() &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造函数 B&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>(); <span class="hljs-comment">// 打印了啥？</span><br><span class="hljs-comment">/* 输出：</span><br><span class="hljs-comment">static A</span><br><span class="hljs-comment">static B</span><br><span class="hljs-comment">&#123;&#125; A</span><br><span class="hljs-comment">构造函数 A</span><br><span class="hljs-comment">&#123;&#125; B</span><br><span class="hljs-comment">构造函数 B</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p><em>考点：Object类有哪些方法？</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Map集合内部使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">// 默认调用 == 比较</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">// 重写这个方法才能clone，但是默认也是浅拷贝；重写方法后自己new对象，可实现深拷贝</span><br><span class="hljs-comment">// 需要申明实现Cloneable接口，虽然这个接口里面啥也没有</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">// 反射相关</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">// GC相关</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;&#125;<br><span class="hljs-comment">// 多线程相关</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br></code></pre></td></tr></table></figure>

<h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p><em>考点：访问权限？</em></p>
<ul>
<li>public所有都可用，protected只在本包内可用（区别：包内包外）</li>
<li>private只在类中可用</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22879930/1653113699585-956c4a95-7533-4155-af6d-627857bb96e4.jpeg#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u4c584645&margin=%5Bobject%20Object%5D&name=%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.jpg&originHeight=240&originWidth=324&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10021&status=done&style=none&taskId=ud8a64e37-7b2f-40c5-aafa-357082cf699&title=" srcset="/img/loading.gif" lazyload alt="访问权限.jpg"></p>
<h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p><em>考点：基础</em></p>
<ul>
<li>一个类可以实现多个接口，但是不能继承多个(抽象)类</li>
<li>接口的字段只能是static和final类型的，而抽象类的字段没有这种限制</li>
<li>接口的成员只能是public的，而抽象类的成员可以有多种访问权限<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceExample</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// Java 8 之后接口都可以有默认的实现方法了</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;func2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="this和super"><a href="#this和super" class="headerlink" title="this和super"></a>this和super</h3><p>访问本类，和访问父类……</p>
<h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p><em>考点：深浅拷贝？</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br><span class="hljs-type">A</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> a1; <span class="hljs-comment">// 指向的是同一块内存，a2 变了，a1也变了，浅拷贝</span><br><span class="hljs-comment">// 自己实现 clone() 方法，因为默认的啥也没干，然后 new 新的对象，赋值，完成深拷贝</span><br></code></pre></td></tr></table></figure>

<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><em>考点：说一下反射，以及用法？</em><br>两个工具：</p>
<ul>
<li>Class类</li>
<li>java.lang.reflect 里面的工具类</li>
</ul>
<p>可以做什么？</p>
<ul>
<li>这个对象属于哪个类？A.class，a.getClass</li>
<li>通过字符串生成对象，Class.forName(“ClassExample”).newInstance();</li>
<li>获取类变量，方法，getFields，getMethods</li>
<li>甚至可以获取值，调用方法，Field::get，Method::invoke</li>
<li>RPC的实现</li>
</ul>
<p><em>通过反射获取私有变量的值？</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> A.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>        f.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 注意是 true</span><br>        System.out.println(f.get(a));<br>		<span class="hljs-comment">// 打印出 123</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113716377-ff4b2f97-973d-4397-85fe-6d1c3a8dcc90.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=344&id=u28201fb1&margin=%5Bobject%20Object%5D&name=Java%E5%BC%82%E5%B8%B8.png&originHeight=458&originWidth=718&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18102&status=done&style=none&taskId=ue789e32f-6f86-40cc-9436-a6dc429872b&title=&width=540" srcset="/img/loading.gif" lazyload alt="Java异常.png"><br><em>考点：Error和Exception的区别？</em></p>
<ul>
<li>Error</li>
</ul>
<p>Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程。直接挂掉。<br>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如，当JVM不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError</p>
<ul>
<li>Exception</li>
</ul>
<p>Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常</p>
<ul>
<li>throw，自己写语句抛出</li>
<li>throws，函数声明的时候，有时候必须加上</li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1033693">10道泛型面试题</a></p>
<h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113746757-e58f27a0-ad36-48e1-9184-8ab268658407.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=351&id=u3304566e&margin=%5Bobject%20Object%5D&name=%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB%E5%9B%BE.png&originHeight=426&originWidth=656&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103878&status=done&style=none&taskId=u1f19d581-46b3-4d60-85ff-bd39f293ef6&title=&width=541" srcset="/img/loading.gif" lazyload alt="集合框架体系图.png"></p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><em>考点：线程安全？内部原理？扩容机制？</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 内部实现，transient 声明的无法被序列化</span><br><span class="hljs-comment">// 内部是一个 Object 数组，默认大小为 10</span><br><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-comment">// 添加元素，先确认容量，不足则扩容，size 记录了当前元素个数，下标 +1</span><br><span class="hljs-comment">// 时间复杂度，O(1)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">// 删除元素，根据下标删除，找到删除的元素，删除后，把后面的元素依次往前挪（System.arraycopy）</span><br><span class="hljs-comment">// 返回删除后的元素，时间复杂度，O(n)</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br>        modCount++;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><span class="hljs-comment">// 扩容，原来的 1.5 倍，采用移位操作更快</span><br><span class="hljs-comment">// int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br></code></pre></td></tr></table></figure>

<ul>
<li>非线程安全</li>
<li>Vector线程安全，同样，增删改加了 synchronized 关键字</li>
</ul>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p><em>考点：内部实现？插入删除复杂度？</em></p>
<ul>
<li>和ArrayList一样，非线程安全</li>
<li>底层数据结构是双向链表</li>
<li>增加节点，尾插法，时间复杂度O(1)</li>
<li>查找节点，得从头节点开始遍历，时间复杂度O(n)</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><em>考点：底层接口？线程安全？put和get源码？</em></p>
<ul>
<li><p>采用数组 + 链表组成的，用拉链法来解决冲突</p>
</li>
<li><p>当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</p>
</li>
<li><p>负载因子，默认是 0.75f。越大，说明越满</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先取一个哈希值</span><br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    &#125;<br><span class="hljs-comment">// 添加元素</span><br>    <span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<br>        <span class="hljs-comment">// 取数组下标直接移位，(n - 1) &amp; hash，为什么？因为数组的长度是 2^n 次方</span><br>        <span class="hljs-comment">// 这个运算就等于 hash % n，位运算更快一些</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-comment">// 只有 hash 相等，且 equals 相等，才会被认为是相同的！</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount;<br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>示意图</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113791417-070661c7-ae97-47e0-9a08-462f4e24b0c9.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=320&id=u38341345&margin=%5Bobject%20Object%5D&name=HashMap%E7%A4%BA%E6%84%8F.png&originHeight=545&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23933&status=done&style=none&taskId=uecf6285d-6f65-4cb0-b427-775b6bb25eb&title=&width=423" srcset="/img/loading.gif" lazyload alt="HashMap示意.png"></p>
<p><em>考点：为什么重写了 hashCode 之后，equal 也要重写？</em></p>
<ul>
<li>内部集合都是这么判断的，只有都相同才认为是一个对象。不重写的话，Set集合里面放了两个相同值的对象</li>
</ul>
<p><em>考点：什么时候导致非线程安全？</em></p>
<ul>
<li>扩充，容量 * 2，所以元素重新 hash，重新放置</li>
<li>非线程安全，扩充的时候，拷贝链表的时候，多线程操作易死循环</li>
</ul>
<p><em>考点：Hashtable是否线程安全？</em><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113827539-e5e71be3-3990-44e4-9462-e08f799582a0.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=217&id=u428b461c&margin=%5Bobject%20Object%5D&name=HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF.png&originHeight=258&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31569&status=done&style=none&taskId=u99523a7d-026d-43be-88d7-afcde6c85e2&title=&width=563" srcset="/img/loading.gif" lazyload alt="HashMap死循环.png"></p>
<ul>
<li>Hashtable，不允许KV为null，synchronized关键字保证它是线程安全的，底层实现一样</li>
<li>HashSet，底层就是一个HashMap，用了一个final的对象作为所有map的value值，HashSet只用key值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// put 方法，里面套了一个 HashMap   </span><br>	<span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>    &#125;<br><span class="hljs-comment">// value 是不变的，只用到了 HashMap 的 key</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><p>总结来自  <strong><em>&lt;&lt;Java虚拟机（第二版）&gt;&gt;</em></strong></p>
<h3 id="JVM分区"><a href="#JVM分区" class="headerlink" title="JVM分区"></a>JVM分区</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113862092-a21f30c4-7b12-4447-ad14-035ec39d4c20.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=428&id=u1c333bcc&margin=%5Bobject%20Object%5D&name=JVM%E5%88%86%E5%8C%BA.png&originHeight=532&originWidth=394&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92558&status=done&style=none&taskId=udbfb3993-6bb3-4d9e-b258-fa1f66ea135&title=&width=317" srcset="/img/loading.gif" lazyload alt="JVM分区.png"><br><em>考点：JVM有哪些区域，分别是线程私有还是共享？</em></p>
<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
<th>线程私有公有</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>保存执行指令</td>
<td>私有</td>
</tr>
<tr>
<td>Java堆</td>
<td>对象new分配的空间</td>
<td>线程共享</td>
</tr>
<tr>
<td>Java栈</td>
<td>存放局部变量，参数等</td>
<td>私有</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>执行的是native方法，变量参数等</td>
<td>私有</td>
</tr>
<tr>
<td>方法区</td>
<td>加载的类、常量池等</td>
<td>线程共享</td>
</tr>
</tbody></table>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><em>考点：拓展回答用</em><br>和TCP报文一样，对象分为对象头和对象内容，对象头包含两个部分：</p>
<ul>
<li><strong>Mark Word</strong>：存放HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li>
</ul>
<p>和并发的知识点联系在一起……</p>
<ul>
<li>类型指针：指示它是哪个类的对象</li>
</ul>
<h3 id="GC的主要场所：堆"><a href="#GC的主要场所：堆" class="headerlink" title="GC的主要场所：堆"></a>GC的主要场所：堆</h3><p><em>考点：对象存活</em><br>对象已死吗？</p>
<ul>
<li>引用计数法</li>
</ul>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不被使用的</p>
<ul>
<li>缺点</li>
</ul>
<p>不能解决循环引用的问题</p>
<ul>
<li>可达性分析法（主流方法）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113912399-660782d2-105a-4cb4-b244-8fa383449ac6.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=251&id=u815e724e&margin=%5Bobject%20Object%5D&name=%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png&originHeight=310&originWidth=541&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14038&status=done&style=none&taskId=u64931d27-aea2-4c9b-b774-af8d49c4ade&title=&width=438" srcset="/img/loading.gif" lazyload alt="可达性分析.png"><br>通过GC Roots作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收，可以作为GC Roots的对象：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<h3 id="方法区也是可以被回收的"><a href="#方法区也是可以被回收的" class="headerlink" title="方法区也是可以被回收的"></a>方法区也是可以被回收的</h3><p><em>考点：方法区的回收</em><br>回收的主要内容：废弃常量和无用的类<br>无用的常量：假如一个字符串”a”没有任何对象引用它，那么这个常量将会被清理出常量池<br>无用的类：</p>
<ul>
<li>该类的所有实例都已经被回收</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<p>满足这些条件的类”可以”被回收，但不是一定被回收。在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</p>
<h3 id="finalize-之对象的重生"><a href="#finalize-之对象的重生" class="headerlink" title="finalize()之对象的重生"></a>finalize()之对象的重生</h3><p><em>考点：final、finally、finalize区别？</em><br>如果对象脱离了”GC Roots”，不一定会非死不可，对于这种对象：</p>
<ul>
<li>如果它的finalize()方法已经执行过了或者没有覆盖这个方法，就直接被GC</li>
<li>否则会被放在F-Queue中，Finalizer线程会依次执行每个对象的finalize()方法，某个对象如果在finalize()中有死循环，会导致回收系统崩溃</li>
<li>如果一个对象在finalize()方法中建立了新的引用，比如把this赋给了活着的对象，那么它就存活了</li>
</ul>
<p>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，就必死无疑；同时，并不鼓励大家使用这种方法来拯救对象</p>
<h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p><em>考点：四种引用</em></p>
<ul>
<li>强引用：被强引用关联的对象不会被回收；new出来的对象</li>
<li>软引用：内存不够才会回收它；使用 SoftReference 类来创建软引用</li>
<li>弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前；使用 WeakReference 类来实现弱引用</li>
<li>虚引用：无法通过虚引用取得一个对象，唯一作用是它被回收时会收到一个系统通知；使用 PhantomReference 来实现虚引用</li>
</ul>
<h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p><em>考点：GC算法</em></p>
<ul>
<li>标记清除</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113942503-5623a5fd-8302-438b-951d-fa38c923112f.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=180&id=u78bc141a&margin=%5Bobject%20Object%5D&name=%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png&originHeight=193&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42149&status=done&style=none&taskId=u9a2c5a61-decc-4dae-8dde-187deda45da&title=&width=518" srcset="/img/loading.gif" lazyload alt="标记清除.png"><br>标记要回收的对象，然后清除</p>
<p>问题：<br>标记和清除的效率都很低；产生内存碎片</p>
<ul>
<li>标记-整理</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113973174-2c9f13c3-23f9-4a00-bb18-12019184d82c.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=195&id=ud09ec603&margin=%5Bobject%20Object%5D&name=%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png&originHeight=204&originWidth=545&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52753&status=done&style=none&taskId=u82ab9132-4fd6-4c11-a637-8d4253a0db0&title=&width=520" srcset="/img/loading.gif" lazyload alt="标记整理.png"><br>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<ul>
<li>复制算法</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113998961-cc1af0ad-e28f-46d6-be60-d6354ebb4079.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=192&id=u1991ef6d&margin=%5Bobject%20Object%5D&name=%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png&originHeight=206&originWidth=572&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82523&status=done&style=none&taskId=uce86a947-d793-4202-b0c2-d7ad2fc224a&title=&width=533" srcset="/img/loading.gif" lazyload alt="复制算法.png"><br>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理</p>
<p>当然浪费一半的内存效率太低了，HotSpot虚拟机采用较大的Eden空间和两块较小的Survivor空间，Eden:Survivor &#x3D; 8:1。GC时把Eden和Survivor存活的对象复制到另一块Survivor上，再清除其它的</p>
<p>如果一块Survivor不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象</p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p><em>考点：分代回收算法</em><br>堆分为新生代和老年代，一般情况下：</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记-清除或者标记-整理算法</li>
</ul>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><em>考点：垃圾收集器</em><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114032580-70755351-90dc-43aa-8900-b39a533709f4.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=334&id=uc90cd887&margin=%5Bobject%20Object%5D&name=%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png&originHeight=387&originWidth=557&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102482&status=done&style=none&taskId=u39681df5-9a1d-49b2-84ff-d2cb1134def&title=&width=480" srcset="/img/loading.gif" lazyload alt="垃圾收集器.png"><br>以上是HotSpot虚拟机中的7个垃圾收集器，连线表示垃圾收集器可以配合使用；主要分为：</p>
<ul>
<li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程</li>
<li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行<table>
<thead>
<tr>
<th>收集器</th>
<th>串行&#x2F;并行</th>
<th>单线程&#x2F;多线程</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>串行</td>
<td>单线程</td>
</tr>
<tr>
<td>ParNew</td>
<td>串行</td>
<td>多线程</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>串行</td>
<td>多线程</td>
</tr>
<tr>
<td>Serial Old</td>
<td>串行</td>
<td>单线程</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>串行</td>
<td>多线程</td>
</tr>
<tr>
<td>CMS</td>
<td>并行</td>
<td>多线程</td>
</tr>
<tr>
<td>G1</td>
<td>并行</td>
<td>多线程</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p><em>考点：Minor GC和Full GC？</em></p>
<ul>
<li>Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快</li>
<li>Full GC：发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多</li>
</ul>
<h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p><em>考点：一个对象的分配策略？</em></p>
<ul>
<li>对象优先在 Eden 分配，当 Eden 区空间不够时，发起 Minor GC</li>
<li>大对象直接进入老年代，避免在 Eden 区和 Survivor 区之间的大量内存复制</li>
<li>长期存活的对象进入老年代，为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中；-XX:MaxTenuringThreshold 用来定义年龄的阈值</li>
<li>动态对象年龄判定，虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄</li>
</ul>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p><em>考点：空间分配担保？</em><br>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的</p>
<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间<strong>是否大于历次晋升到老年代对象的平均大小</strong>，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC</p>
<h4 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h4><p><em>考点：GC条件</em><br>Minor GC</p>
<ul>
<li>其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC</li>
</ul>
<p>Full GC</p>
<ul>
<li>调用 System.gc()，只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行</li>
<li>老年代空间不足</li>
<li>空间分配担保失败</li>
</ul>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><em>考点：类加载，类的生命周期？</em></p>
<ul>
<li>类的生命周期</li>
</ul>
<p>加载，验证，准备，解析，初始化，使用，卸载。7个阶段<br>前5个阶段，类加载：加载，验证，准备，解析，初始化<br>验证，准备，解析合称为链接</p>
<ul>
<li>类的唯一性</li>
</ul>
<p>只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><em>考点：类加载器和双亲委派模型？</em><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114076721-36d58fdf-ef49-4525-b523-fc2219c8cb38.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=163&id=u5cfeabe9&margin=%5Bobject%20Object%5D&name=%E7%B1%BB%E5%8A%A0%E8%BD%BD.png&originHeight=186&originWidth=611&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88103&status=done&style=none&taskId=u1b1471e9-4020-4343-affe-3d346279637&title=&width=537" srcset="/img/loading.gif" lazyload alt="类加载.png"></p>
<ul>
<li>启动类加载器，Bootstrap ClassLoader，这个类加载器使用C++语言实现，是虚拟机本身的一部分</li>
<li>扩展类加载器（Extension ClassLoader）由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的类库</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher $AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</li>
</ul>
<p>双亲委派模型：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114112463-2c43c070-8889-4d2f-9da3-c4ea52646bb2.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=337&id=u17c16c64&margin=%5Bobject%20Object%5D&name=%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png&originHeight=411&originWidth=367&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61258&status=done&style=none&taskId=u11e25f0e-1c9d-4816-ab48-0cf5d75cd15&title=&width=301" srcset="/img/loading.gif" lazyload alt="双亲委派模型.png"><br>启动类加载器-&gt;扩展类加载器-&gt;应用程序类加载器-&gt;自定义类加载器，这种类加载器之间的层次关系，称为双亲委派模型；</p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载</p>
<ul>
<li>作用</li>
</ul>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类</p>
<h4 id="Java客户端程序，服务器程序区别？"><a href="#Java客户端程序，服务器程序区别？" class="headerlink" title="Java客户端程序，服务器程序区别？"></a>Java客户端程序，服务器程序区别？</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114140327-4e5a8533-ee9b-40c9-ac30-177d45fed9de.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=281&id=uce695019&margin=%5Bobject%20Object%5D&name=Java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C.png&originHeight=314&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38242&status=done&style=none&taskId=u25dd4329-d63b-4cf1-9727-afe7f2e063e&title=&width=448" srcset="/img/loading.gif" lazyload alt="Java代码执行.png"><br>Java既可以解释执行（解释执行的效率慢一些），也可以编译执行；Java有多个即时编译器，C1、C2和Graal。<br>C1：面对启动性能较高的GUI客户端程序<br>C2：面向对峰值性能有要求的服务器程序<br>（也是JDK server和JDK client的区别）<br>Java7开始，HotSpot默认采用分层编译的方式：热点方法首先会被C1编译，然后再被C2编译<br>HotSpot 会根据 CPU 的数量设置编译线程的数目，并且按 1:2 的比例配置给 C1 及 C2 编译器，在计算资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行<br>HotSpot装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍</p>
<h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><p>总结来自  <strong><em>&lt;&lt;Java并发编程的艺术&gt;&gt;</em></strong></p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><em>考点：关键字作用？</em><br>讲到这个关键字，可以涉及两个知识点：</p>
<ul>
<li>Java内存模型</li>
<li>重排序：插入内存屏障，防止某些片段的重排，影响语义</li>
</ul>
<p>主内存+线程拷贝内存，为了保证运行的效率，每个线程会从主内存中拷贝副本运行，导致了不同线程看到的变量不一致<br>被关键字修饰的变量，一旦修改，会对所有的线程可见；原理：加了volatile变量后，当这个变量被修改后，汇编代码会多出一行lock指令，这个指令有两个作用：</p>
<ul>
<li>将当前处理器的缓存写回到系统内存中</li>
<li>写回内存的操作使得其它地方的这个缓存副本无效</li>
</ul>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><em>考点：synchronized的作用？底层实现？锁升级？</em><br>底层指令是通过成双的monitorenter和monitorexit来实现的<br>任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁<br>获取锁失败的对象进入同步队列（SynchronizedQueue），状态变为阻塞BLOCKED状态<br>加锁的本质也是一种线程之间的通信<br>锁升级：<br>锁一共分为4个等级，无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不可以降级，区别：</p>
<ul>
<li>无锁，就不说了，不加锁</li>
<li>偏向锁：为了防止一个线程频繁的进入一个同步块，浪费锁；将对象头（JVM中讲到）中的锁信息标明为这个线程的ID，同时有个bool变量0&#x2F;1设置为当前为偏向锁</li>
<li>轻量级锁：将对象的Mark Word拷贝到自己线程的私有空间，就加锁了，若失败，则说明存在竞争；解锁，再把Mark Word替换回去。两个线程只要不同时进入同步块，那就是轻量级锁</li>
<li>重量级锁，当线程获取锁时，都会被阻塞，当持有锁的线程释放锁后会唤醒阻塞的线程，被唤醒的线程就会进行下一轮的夺锁之争；一旦两个线程尝试同时进入，升级为重量级锁</li>
</ul>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p><em>考点：Java内存模型？</em></p>
<h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>Java并发采用的是共享内存模型<br>实例域、静态域和数组元素存储在堆内存中，是线程共享的。局部变量和函数参数存在栈中，不是线程共享，因此不存在内存可见性问题<br>除了主内存以外，每个线程有自己的本地内存，存放主内存中共享变量的副本。副本和实体的同步由JMM（Java内存模型）控制；如果A和B需要通信，A必须把更新过的共享变量刷新到内存中，B要去读已经更新过的共享变量</p>
<h4 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h4><p>在不改变程序执行结果的前提下，尽可能的提高并行度；我们所执行的指令都是经过重排序的结果：编译器重排-&gt;指令重排-&gt;内存重排<br>对于JMM而言，它会禁止特定类型的重排，为程序员提供一致的内存可见性保证</p>
<h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>前一个操作执行的结果必须要对后一个操作可见，不意味着前一个操作必须在后一个操作之前执行</p>
<p>正确加锁的多线程程序，重排序是遵守happens-before原则的，保证程序不会出错</p>
<p>包括volatile关键字和锁，本质就是在重排序的时候加入了<code>内存屏障</code>，防止了某些重排序对程序正确性的影响，保证了多线程运行的正确性</p>
<h3 id="ReentrantLock的实现"><a href="#ReentrantLock的实现" class="headerlink" title="ReentrantLock的实现"></a>ReentrantLock的实现</h3><p>ReentrantLock的实现是基于Java同步器框架AbstractQueuedSynchronizer，简称AQS实现的；而AQS使用了一个整型的volatile变量state来维护同步状态，这个变量是实现锁的关键：</p>
<ul>
<li>加锁先读state</li>
<li>释放锁后更新state</li>
<li>state的更新都是基于CAS操作</li>
</ul>
<p>ReentrantLock中的公平锁和非公平锁：</p>
<ul>
<li>相对于获取锁的时机来定义的，公平锁的获取按照先来先到的顺序，按照队列中的顺序来获取</li>
<li>非公平锁允许”插队”，可以不按顺序来</li>
<li>参数true是公平，false是不公平</li>
</ul>
<p>ReentrantLock是重入锁，顾名思义，可以重复加锁；还是维护state变量，每加锁一次，加1；释放锁一次，减1；当state为0时代表无锁</p>
<h4 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h4><p>使用场景，ReentrantLock：</p>
<ul>
<li>tryLock()接口，可以指定尝试的时间，提供了一种定时结束等待的方式；如果线程在指定的时间没有获取锁，就返回false并停止等待</li>
<li>可中断：lockInterruptibly，等待获取锁的过程中，线程可被中断；不像syn关键字，等不到锁就一直等待（饥饿）</li>
<li>条件队列：线程在获取不到锁后，进入等待状态（Object.wait()方法或者Condition.await()方法），进入等待状态的线程会挂起并释放锁，进入条件队列；synchronized只有一个条件队列，而ReentrantLock有多个（参考阻塞队列中的notFull和notEmpty两个条件队列）</li>
</ul>
<p>何为条件？线程获取锁后，要满足一定的条件才能执行，比如生产者生产，队列满了，只能等待。ReentrantLock可以维护多个条件队列，结合阻塞队列讲</p>
<ul>
<li>公平和非公平：等待syn锁的线程进入队列后，每次随机的从队列中取出一个获取锁，这样导致有些线程饥饿。对于ReentrantLock，可以实现公平锁，先来先到</li>
</ul>
<p>最后，syn关键字是可重入的！可重入的！可重入的！<br>总之：在线程并发比较少的情况下，用syn关键字是很好的选择；在高并发的情况下，需要灵活的使用锁，这个时候用ReentrantLock比较好</p>
<h3 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h3><p>读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rwl.readLock();<br><span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rwl.writeLock();<br></code></pre></td></tr></table></figure>

<h4 id="读写锁是怎么维护重入次数的？"><a href="#读写锁是怎么维护重入次数的？" class="headerlink" title="读写锁是怎么维护重入次数的？"></a>读写锁是怎么维护重入次数的？</h4><p>如图所示，将一个32位的整型变量分成两个16位的区域，分别用来维护读、写的加锁次数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114171600-a5f35965-7dac-42df-ae38-9f5764f02fb4.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=252&id=u833d636e&margin=%5Bobject%20Object%5D&name=%E8%AF%BB%E5%86%99%E9%94%81.png&originHeight=307&originWidth=690&originalType=binary&ratio=1&rotation=0&showTitle=false&size=70157&status=done&style=none&taskId=u2c22a96a-b18b-4c8b-beea-fd13e9b53bc&title=&width=567" srcset="/img/loading.gif" lazyload alt="读写锁.png"></p>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值；编译器不能对CAS与CAS前面和后面的任意内存操作重排序<br>CAS（compareAndSet）的实现，再往下就是sun.misc.Unsafe类的compareAndSwapInt方法，是一个Native方法</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><ul>
<li>创建，new</li>
<li>就绪，调用了start()方法，等CPU调度</li>
<li>运行，CPU执行了run方法</li>
<li>阻塞，停止执行，将资源交给其它线程</li>
<li>终止，线程销毁</li>
</ul>
<h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>setPriority(int)方法来修改优先级，优先级高的线程分配时间片的数量要多于优先级低的线程</p>
<h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作；Thread.setDaemon(true)将线程设置为Daemon线程</p>
<h4 id="构造线程的方法"><a href="#构造线程的方法" class="headerlink" title="构造线程的方法"></a>构造线程的方法</h4><ul>
<li>继承 Thread 类</li>
<li>实现 Runnable 接口</li>
<li>实现 Callable 接口；配合FutureTask使用，有返回值的线程</li>
</ul>
<h4 id="安全的停止线程"><a href="#安全的停止线程" class="headerlink" title="安全的停止线程"></a>安全的停止线程</h4><ul>
<li>interrupt()函数中断线程，中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务</li>
<li>利用一个boolean变量来控制是否需要停止任务并终止该线程</li>
</ul>
<p>过期的方法，不安全：</p>
<ul>
<li>suspend()</li>
<li>resume()</li>
<li>stop()</li>
</ul>
<h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><ul>
<li>volatile和synchronized关键字</li>
<li>管道流输入输出</li>
<li>等待、通知机制</li>
<li>Thread.join()</li>
<li>ThreadLocal</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>从源码分析，每个线程都有一个Map互不干扰，key是当前的this指针即ThreadLocal对象本身，value是线程存的值</p>
<ul>
<li><p>set</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>	<span class="hljs-comment">//首先获取当前的线程</span><br>	<span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>	<span class="hljs-comment">//根据线程获取Map，没有则创建一个，创建后设置值</span><br>	<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>	<span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>		<span class="hljs-comment">//key值为this对象即是当前的ThreadLocal对象</span><br>		map.set(<span class="hljs-built_in">this</span>, value);<br>	<span class="hljs-keyword">else</span><br>		createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>get</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>	<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>	<span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-comment">//getEntry方法也是通过threadLocalHashCode来取值的</span><br>		ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>		<span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>		<span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>		<span class="hljs-keyword">return</span> result;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>只关注1.8版本，不要在意和之前的有什么区别</p>
<ul>
<li>put</li>
</ul>
<p>重点，1.8丢弃了segment分段锁的概念。之前和HashMap操作一样，当找到要放入的位置时：</p>
<ol>
<li>先用casTabAt函数尝试着放，若放入，则OK。否则说明存在并发操作</li>
<li>再用synchronized关键字对当前链表头节点加锁，再进行安全的put</li>
</ol>
<p>稍后看看源码</p>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>一个基于单链表的队列，它维护了两个重要的节点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//头节点和为节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; head;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; tail;<br></code></pre></td></tr></table></figure>

<ul>
<li>入队列使用CAS操作重新定位尾节点，不成功则循环操作</li>
<li>出队列使用CAS操作定义头节点</li>
</ul>
<p>整个队列没有加锁，全靠CAS操作，使得效率较高</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul>
<li>插入阻塞：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满</li>
<li>移除阻塞：意思是在队列为空时，获取元素的线程会等待队列变为非空</li>
</ul>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器<br>JDK7有7个阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li>
</ul>
<p>阻塞队列的实现原理：<br>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用</p>
<h4 id="重点分析两个"><a href="#重点分析两个" class="headerlink" title="重点分析两个"></a>重点分析两个</h4><ul>
<li><p>ArrayBlockingQueue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        checkNotNull(e);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        <span class="hljs-comment">// 如果当前线程未被中断则获得锁,如果当前线程被中断则出现异常</span><br>        <span class="hljs-comment">// 本身这个等待可以被中断的</span><br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == items.length)<br>                notFull.await();<br>            enqueue(e);<br>            <span class="hljs-comment">// notEmpty.signal();</span><br>            <span class="hljs-comment">// 入队列后唤醒消费者</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>&#125;<br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>                notEmpty.await();<br>            <span class="hljs-keyword">return</span> dequeue();<br>            <span class="hljs-comment">// notFull.signal();</span><br>            <span class="hljs-comment">// 出队列后唤醒生产者</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>LinkedBlockingQueue</p>
</li>
</ul>
<p>大致是一样的，有一些小区别：</p>
<ol>
<li>基于链表，创建时不需要指定大小</li>
<li>ArrayBlockingQueue使用的是一个lock，而LinkedBlockingQueue采用的是putLock和takeLock；意味这两个线程可以同时操作头尾</li>
</ol>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>原子类实现的方式大同小异，这里就分析一下AtomicInteger，提供的方法（有点过时了）：</p>
<ul>
<li>int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果</li>
<li>boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值</li>
<li>int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值</li>
<li>void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值</li>
<li>int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值</li>
</ul>
<h4 id="循环CAS"><a href="#循环CAS" class="headerlink" title="循环CAS"></a>循环CAS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br>	<span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> get();<br>	<span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">if</span> (compareAndSet(current, next))<br>		<span class="hljs-keyword">return</span> current;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>循环CAS的操作是可以保证原子性的，JDK1.7之前for循环 + compareAndSet，直到成功为止！compareAndSet底层也是Unsafe类<br>JDK1.8直接调用的Unsafe类的相关方法</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="创建方式1"><a href="#创建方式1" class="headerlink" title="创建方式1"></a>创建方式1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">通过 Executors.newXXX 创建，其底层是调用 new ThreadPoolExecutor</span><br><span class="hljs-comment">来实现的，只不过传参不同</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 0~Integer.MAX_VALUE，任务来了无线创建线程，线程执行完后（闲置） 1 分钟销毁</span><br><span class="hljs-comment">// 阻塞队列：SynchronousQueue，长度为 0</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool1</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><span class="hljs-comment">// 核心线程=最大线程=参数，执行完后立即销毁</span><br><span class="hljs-comment">// 阻塞队列：LinkedBlockingQueue，长度为 MAX_VALUE</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool2</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">缺点都很明显，可以无限的 put 线程，也没有拒绝策略，导致 OOM 问题!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h4 id="创建方式2"><a href="#创建方式2" class="headerlink" title="创建方式2"></a>创建方式2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">poo3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">5</span>,          <span class="hljs-comment">// 核心线程池数量</span><br>                <span class="hljs-number">10</span>,    <span class="hljs-comment">// 最大线程池数量</span><br>                <span class="hljs-number">60</span>,       <span class="hljs-comment">// 闲置后销毁时间</span><br>                TimeUnit.SECONDS,       <span class="hljs-comment">// 时间单位</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">10</span>)<br>                <span class="hljs-comment">// 阻塞队列</span><br>        );<br></code></pre></td></tr></table></figure>
<p>线程池的参数：</p>
<ul>
<li>corePoolSize，核心线程数：超过此值将任务加入阻塞队列</li>
<li>maximumPoolSize，最大线程数：阻塞队列已满？线程数量扩至此值，需要获取全局锁</li>
<li>keepAliveTime，unit：线程闲置后的销毁时间以及时间单位</li>
<li>BlockingQueue：指定阻塞队列</li>
<li>ThreadFactory：线程工程，它是个接口，里面就一个方法<code>newThread</code>，默认使用的<code>DefaultThreadFactory</code>，就是创建线程的时候加一些修饰，比如设置为后台线程，改下名字之类</li>
</ul>
<h4 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h4><p>JDK1.8，线程池的<code>execute</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 写的比较巧妙，函数和if判断写在一起</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>       <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>	<span class="hljs-comment">// addWorker第二次参数，true是比较corePoolSize，false是比较maximumPoolSize</span><br>       <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>           <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>               <span class="hljs-keyword">return</span>;<br>           c = ctl.get();<br>       &#125;<br>       <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>           <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>               reject(command);<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>               addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>           reject(command);<br>   &#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>如果当前运行的Worker线程小于corePoolSize，直接增加Worker，调用addWorker方法。</li>
<li>addWorker失败后，如果线程池处于运行状态，就把任务放到阻塞队列；然后立马再次检查一遍，如果线程池不处于运行状态，就从队列中移除任务，并且调用拒绝策略</li>
<li>这里JDK1.8和1.7的写法有些变动，如果线程池还是运行的，并且线程数为0（担心任务提交到队列中了，但是线程都关闭），再次调用addWorker方法</li>
<li>入队列失败，在不超过maximumPoolSize大小的情况下再次addWorker；如果失败，任务将被拒绝，并且调用拒绝策略来处理</li>
</ol>
<h4 id="何为Worker？"><a href="#何为Worker？" class="headerlink" title="何为Worker？"></a>何为Worker？</h4><p>对当前的工作线程进行一个封装，成了一个Worker线程；addWorker方法：这个方法允许失败，首先先用循环CAS的方法，把当前的线程数poolSize+1，然后新建一个Worker，加锁mainLock，把新建的Worker放到worker队列里面</p>
<h4 id="四种拒绝策略："><a href="#四种拒绝策略：" class="headerlink" title="四种拒绝策略："></a>四种拒绝策略：</h4><p>默认直接抛出RejectedExecutionException异常<br>还有另外三种：</p>
<ul>
<li>只要线程池没有关闭，那么由提交任务的线程来自己执行这个任务；</li>
<li>不做任何处理，直接丢弃</li>
<li>把队列头的任务丢弃，把新任务加到队列中</li>
</ul>
<h4 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h4><ul>
<li><p>无返回值的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">threadsPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>	<span class="hljs-comment">// TODO Auto-generated method stub</span><br>	&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>有返回值的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// harReturnValuetask 被包装为 FutureTask</span><br>Future&lt;Object&gt; future = executor.submit(harReturnValuetask);<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 如果返回值未到，获取会阻塞！</span><br>	<span class="hljs-type">Object</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> future.get();<br>	&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>	<span class="hljs-comment">// 处理中断异常</span><br>	&#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>	<span class="hljs-comment">// 处理无法执行任务异常</span><br>	&#125; <span class="hljs-keyword">finally</span> &#123;<br>	<span class="hljs-comment">// 关闭线程池</span><br>	executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><p>shutdown或shutdownNow方法</p>
<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>阻塞队列已经实现了生产者，消费者模型。所以直接复用阻塞队列的代码是标准答案<br>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductConsume</span> &#123;<br>    <span class="hljs-comment">// 1 把锁，1个队列，2个条件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">full</span> <span class="hljs-operator">=</span> reentrantLock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">empty</span> <span class="hljs-operator">=</span> reentrantLock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> reentrantLock;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lockInterruptibly();<br>                <span class="hljs-keyword">while</span> (list.size() == MAX_SIZE) &#123;<br>                    full.await();<br>                &#125;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;data&quot;</span>;<br>                list.add(data);<br>                empty.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> reentrantLock;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lockInterruptibly();<br>                <span class="hljs-keyword">while</span> (list.size() == <span class="hljs-number">0</span>) &#123;<br>                    empty.await();<br>                &#125;<br>                list.remove(<span class="hljs-number">0</span>);<br>                full.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><p><a target="_blank" rel="noopener" href="https://www.javadoop.com/post/java-nio">NIO三大组件</a><br><a target="_blank" rel="noopener" href="https://www.javadoop.com/post/nio-and-aio#%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%20IO">NIO详解</a><br>了解就行，谈谈自己的理解<br>CPU在执行任务的时候，可以分为两种任务：1. 几乎不耗时的，例如执行代码逻辑；2. 消耗时间的，与外部系统做IO，数据库连接、网络连接等。当两种任务在一起时，拉低了CPU的执行相率!为什么，CPU在做数据库连接的时候，CPU的时间消耗在等待上!CPU空闲了，没有得到充分的利用</p>
<ul>
<li>同步，发出请求，等待完成，然后返回结果</li>
<li>异步，发出请求，不等待结果（如果你一定要立马得到结果才能进行下一步的操作，这是肯定要阻塞的，future.get），继续往后执行，传入回调函数。第三方完成后将结果写入回调函数，回调你，告知已完成</li>
</ul>
<p>两种IO：<br>阻塞IO即是同步IO，非阻塞IO即为异步IO</p>
<h3 id="网络IO的发展"><a href="#网络IO的发展" class="headerlink" title="网络IO的发展"></a>网络IO的发展</h3><ul>
<li>阻塞IO</li>
</ul>
<p>早期的网络服务，来一个请求就创建一个线程，处理完请求后返回。缺点很多：</p>
<ol>
<li>线程得不到管理，线程的创建和销毁开销很大，极其浪费CPU资源</li>
<li>无限制请求岂不是崩盘？</li>
</ol>
<p>改进：利用线程池来管理线程的创建，使得线程复用。但是治标不治本，一旦线程过多，频繁的上下文切换也顶不住</p>
<ul>
<li>异步IO</li>
</ul>
<p>基于事件驱动的模型，一个线程用到轮训请求，足矣，因为不等待，收到一个请求发出事件即可。<br>由其它的处理线程，处理完后告知结果（只发出IO指令，不处理IO结果）</p>
<h3 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select,poll,epoll"></a>select,poll,epoll</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lxmhhy/p/6214113.html">博客</a></p>
<h2 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/40d0a6ad21d2">SpringIOC和AOP原理</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4ca039a2272">深入理解 Spring 之源码剖析IOC</a><br>了解即可</p>
<h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC控制反转和DI依赖注入是一个意思，都是把创建对象实例的权利交给容器？以往我们写后端程序，Controller层调用Service层，Service调用Dao层，这样直接new出来，层与层之间存在很强的依赖关系，现在是把new的过程交给Spring容器</p>
<p>IOC注入过程：</p>
<ul>
<li>XMLReader去解析我们的xml配置文件，把XML解析成BeanDefinitions，最后把beanDefinition注册到BeanFactory中</li>
<li>注册，以beanName为key，beanDefinition为value，放到ConcurrentHashMap中</li>
</ul>
<p>如何创建Bean实例并构建Bean的依赖关系网？</p>
<ul>
<li>beanFactory.preInstantiateSingletons()，该方法首先循环所有的BeanNames，并且调用getBean方法；递归完成注入</li>
<li>getBean的关键代码createBeanInstance和populateBean；一个是创建类的实例，一个是给类注入依赖</li>
<li>注入的过程会判断是不是基本数据类型（int之类），如果不是，通过获取构造器，反射创建实例</li>
</ul>
<p>BeanDefinition核心数据结构：<br>每个bean都有自己的信息，各个属性，类名，类型，是否单例；除了此以外，Spring通过定义 BeanDefinition 来管理基于Spring的应用中的各种对象以及他们直接的相互依赖关系；它是容器实现IOC的核心数据结构</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>代理模式；我们在写业务代码时，有很多非业务功能每个地方都要用到，比如写日志、事务管理、权限什么的，我们不可能在每个地方都写代码兼顾这些东西；Spring就通过AOP来帮我们做这些东西，用到了代理模式，通过一个注解来帮我们做事务管理<br>AOP源码解析：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/downey/p/4888451.html">源码解析</a></p>
<ul>
<li>声明式Spring AOP代理工厂对象ProxyFactoryBean，ProxyFactoryBean是Spring中一个非常灵活的创建AOP应用的底层方法，封装了AOP的主要功能</li>
<li>ProxyFactoryBean生成AOP Proxy代理对象</li>
<li>DefaultAopProxyFactory创建AOP Proxy代理对象，代理的过程中：如果配置的目标类是接口，则使用JDK的动态代理机制来生成AOP代理，如果使用的不是接口，则使用CGLIB方式来生成AOP的动态代理</li>
<li>DefaultAopProxyFactory的手下有CglibProxyFactory和JdkDynamicAopProxy</li>
</ul>
<p>JDK代理和Cglib代理区别：</p>
<ul>
<li>JDK动态代理：只能代理实现了接口的类，通过实现InvocationHandler这个接口的invoke方法来实现，并在方法前后加上自己想添加的功能；通过字节码框架动态的生成字节码，获取class信息后再通过反射生成实例</li>
<li>Cglib代理：直接代理委托类，它的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，所以不能对final修饰的类进行代理</li>
</ul>
<h3 id="Spring-MVC流程"><a href="#Spring-MVC流程" class="headerlink" title="Spring MVC流程"></a>Spring MVC流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114215155-caf50e06-8c37-453a-888a-0bb77c47dd17.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=359&id=u7d084200&margin=%5Bobject%20Object%5D&name=springmvc%E6%B5%81%E7%A8%8B.png&originHeight=442&originWidth=689&originalType=binary&ratio=1&rotation=0&showTitle=false&size=264041&status=done&style=none&taskId=u3210f93e-39eb-475d-abd4-01270693107&title=&width=559" srcset="/img/loading.gif" lazyload alt="springmvc流程.png"></p>
<ol>
<li>用户发起一个request请求，如果有多个DispatcherServlet，则通过Servletmapping去指定执行的DispatcherServlet</li>
<li>DispatcherServlet把根据URL请求，去HandlerMapping中查找注册了的URL映射，并返回相应的Handler（一个Controller，多个拦截器），给DispatcherServlet</li>
<li>DispatcherServlet传递Handler给HandlerAdapter去执行，返回一个ModelAndView</li>
<li>DispatcherServlet把ModelAndView传递给视图解析器去解析，返回一个视图view</li>
<li>组装上Model数据后变成Response请求返回给客户端</li>
</ol>
<h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>在Web项目启动的时候，URL信息都被保存在HandlerMapping中；遍历这个Map，找到相应的Handler，也就是哪个类的哪个方法，找到方法执行</p>
<h3 id="Spring中用到的设计模式"><a href="#Spring中用到的设计模式" class="headerlink" title="Spring中用到的设计模式"></a>Spring中用到的设计模式</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dream-to-pku/p/9540387.html">Spring中的设计模式</a></p>
<ul>
<li>BeanFactory的getBean方法去获取Bean就是一个简单工厂</li>
<li>定义一个用于创建对象的接口，让子类决定去实例化哪一个类。Factory Method使一个类的实例化延迟到子类，Spring中的FactoryBean就是典型的工厂方法模式</li>
<li>保证一个类仅有一个实例；对象作用域singleton</li>
<li>代理模式；AOP</li>
<li>观察者，Spring中Observer模式常用的地方是listener的实现。如ApplicationListener</li>
</ul>
<h3 id="Spring-Bean-的生命周期和作用域"><a href="#Spring-Bean-的生命周期和作用域" class="headerlink" title="Spring Bean 的生命周期和作用域"></a>Spring Bean 的生命周期和作用域</h3><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Spring Bean 生命周期比较复杂，可以分为创建和销毁两个过程<br>创建Bean：</p>
<ul>
<li>实例化 Bean 对象</li>
<li>设置 Bean 属性</li>
<li>如果我们通过各种 Aware 接口声明了依赖关系，则会注入 Bean 对容器基础设施层面的依赖</li>
<li>调用 BeanPostProcessor 的前置初始化方法 postProcessBeforeInitialization</li>
<li>如果实现了 InitializingBean 接口，则会调用 afterPropertiesSet 方法</li>
<li>调用 Bean 自身定义的 init 方法</li>
<li>调用 BeanPostProcessor 的后置初始化方法 postProcessAfterInitialization</li>
</ul>
<p>销毁Bean：<br>Spring Bean 的销毁过程会依次调用 DisposableBean 的 destroy 方法和 Bean 自身定制的 destroy 方法</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li>Singleton，这是 Spring 的默认作用域，也就是为每个 IOC 容器创建唯一的一个 Bean 实例</li>
<li>Prototype，针对每个 getBean 请求，容器都会单独创建一个 Bean 实例（使用 Prototype 作用域需要经过仔细思考，毕竟频繁创建和销毁 Bean 是有明显开销的）</li>
</ul>
<p>如果是 Web 容器，则支持另外三种作用域：</p>
<ul>
<li>Request，为每个 HTTP 请求创建单独的 Bean 实例</li>
<li>Session，很显然 Bean 实例的作用域是 Session 范围</li>
<li>GlobalSession，GlobalSession提供一个全局性的 HTTP Session</li>
</ul>
<h4 id="Autowire和-Resource的区别？"><a href="#Autowire和-Resource的区别？" class="headerlink" title="@Autowire和@Resource的区别？"></a>@Autowire和@Resource的区别？</h4><table>
<thead>
<tr>
<th>对比项</th>
<th>@Autowire</th>
<th>@Resource</th>
</tr>
</thead>
<tbody><tr>
<td>注解来源</td>
<td>Spring注解</td>
<td>JDK注解(JSR-250标准注解，属于J2EE)</td>
</tr>
<tr>
<td>装配方式</td>
<td>优先按类型（by type）</td>
<td>优先按名称（by name）</td>
</tr>
<tr>
<td>属性</td>
<td>required</td>
<td>name、type</td>
</tr>
<tr>
<td>作用范围</td>
<td>字段、setter方法、构造器</td>
<td>字段、setter方法</td>
</tr>
</tbody></table>
<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h4 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h4><ul>
<li>应用层</li>
<li>表示层：数据压缩，加密等</li>
<li>会话层：会话的创建和管理</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h4 id="经典五层"><a href="#经典五层" class="headerlink" title="经典五层"></a>经典五层</h4><ul>
<li>应用层：HTTP，DNS</li>
<li>传输层：TCP，UDP</li>
<li>网络层：为主机提供数据传输服务，传输层是为主机中的进程提供传输服务</li>
<li>数据链路层：主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务</li>
<li>物理层：传输媒介</li>
</ul>
<h4 id="TCP-x2F-IP四层"><a href="#TCP-x2F-IP四层" class="headerlink" title="TCP&#x2F;IP四层"></a>TCP&#x2F;IP四层</h4><ul>
<li>应用层</li>
<li>传输层</li>
<li>网际层</li>
<li>网路接口层</li>
</ul>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h4><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务，域名具有树状结构，从上到下依次为：根域名、顶级域名、二级域名</p>
<h4 id="FTP文件传输协议"><a href="#FTP文件传输协议" class="headerlink" title="FTP文件传输协议"></a>FTP文件传输协议</h4><p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件</p>
<h4 id="DHCP动态主机配置协议"><a href="#DHCP动态主机配置协议" class="headerlink" title="DHCP动态主机配置协议"></a>DHCP动态主机配置协议</h4><p>用户不再需要去手动配置 IP 地址等信息</p>
<h4 id="TELNET远程登录协议"><a href="#TELNET远程登录协议" class="headerlink" title="TELNET远程登录协议"></a>TELNET远程登录协议</h4><h4 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h4><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议<br>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP</p>
<h4 id="Web请求"><a href="#Web请求" class="headerlink" title="Web请求"></a>Web请求</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xianyulaodi/p/6547807.html">在网页中输入url后发生了什么？</a></p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道</p>
<h4 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h4><ul>
<li><p>用户数据报协议 UDP（User Datagram Protocol）：无连接，没有拥塞控制，面向报文的；支持一对一、一对多、多对一和多对多的交互通信</p>
</li>
<li><p>传输控制协议 TCP（Transmission Control Protocol）：面向连接的，提供可靠的交互，有流量控制、拥塞控制，提供全双工通信，面向字节流，每一条TCP通信只能是一对一的</p>
<h4 id="TCP和UDP报文"><a href="#TCP和UDP报文" class="headerlink" title="TCP和UDP报文"></a>TCP和UDP报文</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114243554-f9f7626f-db8a-4d0b-bfcd-04b400553eb9.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=279&id=uf85ca9a2&margin=%5Bobject%20Object%5D&name=UDP%E6%8A%A5%E6%96%87.png&originHeight=306&originWidth=569&originalType=binary&ratio=1&rotation=0&showTitle=false&size=107210&status=done&style=none&taskId=uf92b58df-ff47-4006-89f6-fc4394f69ff&title=&width=518" srcset="/img/loading.gif" lazyload alt="UDP报文.png"><br>UDP首部只有8个字节：</p>
</li>
<li><p>源端口</p>
</li>
<li><p>目的端口</p>
</li>
<li><p>长度</p>
</li>
<li><p>校验和<br>分别占两个字节</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114268160-3e368838-c85c-4ebe-9de8-e7c47a46e586.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=419&id=ubaf30aef&margin=%5Bobject%20Object%5D&name=TCP%E6%8A%A5%E6%96%87.png&originHeight=493&originWidth=691&originalType=binary&ratio=1&rotation=0&showTitle=false&size=142509&status=done&style=none&taskId=u71475384-adb2-4f42-9cb1-b04531bbe01&title=&width=587" srcset="/img/loading.gif" lazyload alt="TCP报文.png"><br>TCP头部最少20个字节，重点：</p>
<ul>
<li>序号：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401</li>
<li>确认号：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701</li>
<li>数据偏移：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度</li>
<li>确认ACK：当 ACK&#x3D;1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1</li>
<li>同步SYN：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1</li>
<li>终止FIN：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接</li>
<li>窗口：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的</li>
</ul>
<h4 id="TCP建立连接的三次握手"><a href="#TCP建立连接的三次握手" class="headerlink" title="TCP建立连接的三次握手"></a>TCP建立连接的三次握手</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114300903-efa4c68c-341c-4570-ad24-b66edc2f95db.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=301&id=u2c12b962&margin=%5Bobject%20Object%5D&name=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&originHeight=350&originWidth=614&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92312&status=done&style=none&taskId=uf96588ed-1c80-44b6-b6f0-ea2028b24ff&title=&width=528" srcset="/img/loading.gif" lazyload alt="三次握手.png"><br>假设 A 为客户端，B 为服务器端：</p>
<ul>
<li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求</li>
<li>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0，选择一个初始的序号 x</li>
<li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也选择一个初始的序号 y</li>
<li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1</li>
<li>B 收到 A 的确认后，连接建立</li>
</ul>
<p>三次握手的原因：<br>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接；并且确保只建立一个连接</p>
<p>《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”</p>
<h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114336621-09b7e6d9-e5b3-4ce0-850e-e0e9a9bd854d.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=345&id=uddf4127a&margin=%5Bobject%20Object%5D&name=TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png&originHeight=377&originWidth=548&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116016&status=done&style=none&taskId=u1a0722de-40e9-48cd-bd3a-2d15bfcd8cc&title=&width=501" srcset="/img/loading.gif" lazyload alt="TCP四次挥手.png"><br>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1：</p>
<ul>
<li>A 发送连接释放报文，FIN&#x3D;1</li>
<li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据</li>
<li>当 B 不再需要连接时，发送连接释放报文，FIN&#x3D;1</li>
<li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接</li>
<li>B 收到 A 的确认后释放连接</li>
</ul>
<p>四次挥手的原因：<br>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文</p>
<p>TIME_WAIT：<br>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生</li>
<li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文<h4 id="TCP如何可靠传输？"><a href="#TCP如何可靠传输？" class="headerlink" title="TCP如何可靠传输？"></a>TCP如何可靠传输？</h4>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段<br>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，超时时间 RTO 应该略大于 RTTs<h4 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h4>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小</li>
</ul>
<p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口</p>
<p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114370101-e378b884-acd6-4ee9-9731-2a988d920af4.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=252&id=u3120333e&margin=%5Bobject%20Object%5D&name=TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png&originHeight=304&originWidth=742&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141108&status=done&style=none&taskId=u0203e10b-384b-4387-8c6a-ef64660f8fa&title=&width=614" srcset="/img/loading.gif" lazyload alt="TCP滑动窗口.png"></p>
<h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收</p>
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据</p>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率</p>
<p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复，发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口</p>
<p>慢开始与拥塞避免：<br>发送的最初执行慢开始，令 cwnd &#x3D; 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p>
<p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1</p>
<p>如果出现了超时，则令 ssthresh &#x3D; cwnd &#x2F; 2，然后重新执行慢开始</p>
<p>快重传与快恢复：<br>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认</p>
<p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3</p>
<p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh &#x3D; cwnd &#x2F; 2 ，cwnd &#x3D; ssthresh，注意到此时直接进入拥塞避免</p>
<p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务<br>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络<br>与 IP 协议配套使用的还有三个协议：</p>
<ul>
<li>地址解析协议 ARP（Address Resolution Protocol）</li>
<li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li>
<li>网际组管理协议 IGMP（Internet Group Management Protocol）</li>
</ul>
<h4 id="IP报文"><a href="#IP报文" class="headerlink" title="IP报文"></a>IP报文</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114396304-55df5c5b-95e7-439f-a41a-ca1cf4c35bc3.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=330&id=ufe93a412&margin=%5Bobject%20Object%5D&name=IP%E6%8A%A5%E6%96%87.png&originHeight=362&originWidth=655&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116864&status=done&style=none&taskId=u5e8f5d61-2699-4c24-81f9-ce34e702013&title=&width=598" srcset="/img/loading.gif" lazyload alt="IP报文.png"><br>主要的变量：</p>
<ul>
<li>版本 : 有 4（IPv4）和 6（IPv6）两个值</li>
<li>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充</li>
<li>区分服务 : 用来获得更好的服务，一般情况下不使用</li>
<li>总长度 : 包括首部长度和数据部分长度</li>
<li>生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报</li>
<li>协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等</li>
<li>首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量</li>
<li>标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符</li>
<li>片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节</li>
</ul>
<h4 id="IP地址编址方式"><a href="#IP地址编址方式" class="headerlink" title="IP地址编址方式"></a>IP地址编址方式</h4><ol>
<li>分类<br>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114423825-2c2f9280-d3dd-4046-9f57-3ac442e6cfa0.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc3a9dca0&margin=%5Bobject%20Object%5D&name=IP%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86.png&originHeight=281&originWidth=477&originalType=binary&ratio=1&rotation=0&showTitle=false&size=78409&status=done&style=none&taskId=u1da6eab9-b4cb-42a1-b13e-27ff4adb11e&title=" srcset="/img/loading.gif" lazyload alt="IP地址划分.png"></p>
<ol start="2">
<li>子网划分</li>
<li>无分类<br>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化</li>
</ol>
<h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信<br>ARP 实现由 IP 地址得到 MAC 地址<br>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表<br>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射</p>
<h4 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h4><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议<br>ICMP 报文分为差错报告报文和询问报文</p>
<ol>
<li>Ping<br>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。<br>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</li>
<li>Traceroute<br>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。<br>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</li>
</ol>
<ul>
<li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li>
<li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li>
<li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li>
<li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li>
</ul>
<h4 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h4><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ol>
<li>封装成帧<br> 将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束</li>
<li>透明传输</li>
</ol>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p>
<ul>
<li>单工通信：单向传输</li>
<li>半双工通信：双向交替传输</li>
<li>全双工通信：双向同时传输</li>
</ul>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114463128-076d2156-0dc6-4090-aeb8-dd263206da1d.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=225&id=uadc8975a&margin=%5Bobject%20Object%5D&name=HTTP%E5%8D%8F%E8%AE%AE.png&originHeight=267&originWidth=609&originalType=binary&ratio=1&rotation=0&showTitle=false&size=94095&status=done&style=none&taskId=ufda36809-13eb-4a38-a721-bfcfd72a571&title=&width=513" srcset="/img/loading.gif" lazyload alt="HTTP协议.png"></p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>GET请求：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/adcreate/application?application_id=1497002130351668</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost:3000<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Postman-Token</span><span class="hljs-punctuation">: </span>b3c12acc-642b-f772-7960-fbf0cad53f8b<br></code></pre></td></tr></table></figure>
<p>POST请求：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">POST</span> /aduser/login HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Host</span>: localhost:<span class="hljs-number">3000</span><br><span class="hljs-attribute">Content</span>-Type: application/x-www-form-urlencoded<br><span class="hljs-attribute">Cache</span>-Control: no-cache<br><span class="hljs-attribute">Postman</span>-Token: aeaca64f-ba58-<span class="hljs-number">633</span>d-<span class="hljs-number">07</span>bb-dc977c2390f9<br><span class="hljs-attribute">account</span>=tangjing&amp;password=<span class="hljs-number">123456</span>  //POST传参<br></code></pre></td></tr></table></figure>

<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114490201-6b07d836-b781-4082-930d-a62c82094dac.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=220&id=u20a31796&margin=%5Bobject%20Object%5D&name=HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png&originHeight=259&originWidth=699&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20400&status=done&style=none&taskId=ueb65f523-9212-4e7b-9b18-95687cd3445&title=&width=594" srcset="/img/loading.gif" lazyload alt="HTTP响应报文.png"></p>
<h4 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h4><h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p>获取资源</p>
<h5 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h5><p>获取报文首部，和 GET 方法一样，但是不返回报文实体主体部分</p>
<h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>POST 主要用来传输数据，而 GET 主要用来获取资源</p>
<h5 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h5><p>上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</p>
<h5 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h5><p>对资源进行部分修改，PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改</p>
<h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>删除文件，与 PUT 功能相反，并且同样不带验证机制</p>
<h5 id="GET-和-POST-比较？"><a href="#GET-和-POST-比较？" class="headerlink" title="GET 和 POST 比较？"></a>GET 和 POST 比较？</h5><ul>
<li>传参，GET为URL传参，POST为body传参</li>
<li>安全。GET是获取资源，不会改变资源，因此相对于POST较安全</li>
<li>幂等性（幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的），POST没有幂等性</li>
<li>可缓存性，POST 在多数情况下不可缓存的</li>
</ul>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h4 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h4><ul>
<li><p>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</p>
<h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4></li>
<li><p>200 OK</p>
</li>
<li><p>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用</p>
</li>
<li><p>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容</p>
</li>
</ul>
<h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><ul>
<li>301 Moved Permanently ：永久性重定向</li>
<li>302 Found ：临时性重定向（都是资源的地址被修改了，需要重定向一下）</li>
<li>304，资源未修改，不需要重复请求了</li>
<li>305，必须通过代理访问资源，代理的地址在Response 的Location中</li>
</ul>
<h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><ul>
<li>400 Bad Request ：请求报文中存在语法错误</li>
<li>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败</li>
<li>403 Forbidden ：请求被拒绝</li>
<li>404 Not Found</li>
</ul>
<h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h4><ul>
<li>500 Internal Server Error ：服务器正在执行请求时发生错误</li>
<li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li>
</ul>
<h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>控制不再转发给代理的首部字段、管理持久连接</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
<h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web 认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与 If-Match 相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体 Byte 的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与 If-Modified-Since 相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中 URI 的原始获取方</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP 客户端程序的信息</td>
</tr>
</tbody></table>
<h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定 URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发起请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP 服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody></table>
<h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><table>
<thead>
<tr>
<th>首部字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源可支持的 HTTP 方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的 URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期时间</td>
</tr>
</tbody></table>
<h3 id="HTTP应用"><a href="#HTTP应用" class="headerlink" title="HTTP应用"></a>HTTP应用</h3><p>短连接与长连接：<br>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大</p>
<p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信</p>
<ul>
<li>从 HTTP&#x2F;1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；</li>
<li>在 HTTP&#x2F;1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive</li>
</ul>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP 有以下安全性问题：</p>
<ul>
<li>使用明文进行通信，内容可能会被窃听</li>
<li>不验证通信方的身份，通信方的身份有可能遭遇伪装</li>
<li>无法证明报文的完整性，报文有可能遭篡改<br>HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPs 使用了隧道进行通信。<br>通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</li>
</ul>
<p>开销：</p>
<ul>
<li>因为需要进行加密解密等过程，因此速度会更慢；</li>
<li>需要支付证书授权的高额费用</li>
</ul>
<h3 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><h4 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h4><p>HTTP&#x2F;2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114530619-9e7e63f5-771d-4da2-b3d1-edea58b28b75.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uae3ea938&margin=%5Bobject%20Object%5D&name=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8A%A5%E6%96%87.png&originHeight=317&originWidth=372&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35943&status=done&style=none&taskId=uf1dc494c-5e3f-4847-b274-a04e82f625d&title=" srcset="/img/loading.gif" lazyload alt="二进制报文.png"><br>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）</p>
<h4 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h4><p>HTTP&#x2F;2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端</p>
<h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p>HTTP&#x2F;1.1 的首部带有大量信息，而且每次都要重复发送</p>
<p>HTTP&#x2F;2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输</p>
<p>不仅如此，HTTP&#x2F;2.0 也使用 Huffman 编码对首部字段进行压缩</p>
<h3 id="HTTP1-1新特性"><a href="#HTTP1-1新特性" class="headerlink" title="HTTP1.1新特性"></a>HTTP1.1新特性</h3><ul>
<li>默认是长连接</li>
<li>支持流水线，在一个TCP连接内，多个HTTP请求可以并行，客户端不用等待上一次请求结果返回，就可以发出下一次请求</li>
<li>支持同时打开多个 TCP 连接</li>
<li>支持虚拟主机</li>
<li>新增状态码 100</li>
<li>支持分块传输编码</li>
<li>新增缓存处理指令 max-age</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/52d86558ca57">如何优雅的谈论HTTP／1.0／1.1／2.0</a></p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="并发-amp-并行"><a href="#并发-amp-并行" class="headerlink" title="并发&amp;并行"></a>并发&amp;并行</h4><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令；并行需要硬件支持，如多流水线或者多处理器</p>
<h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>共享是指系统中的资源可以被多个并发进程共同使用，共享方式：</p>
<ul>
<li>互斥共享：互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问</li>
<li>同时共享</li>
</ul>
<h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><p>虚拟技术把一个物理实体转换为多个逻辑实体，主要有两种：</p>
<ul>
<li>时分复用技术：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换</li>
<li>空分复用技术：比如虚拟内存，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间和物理内存使用页进行交换，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中</li>
</ul>
<h3 id="操作系统的基本功能？"><a href="#操作系统的基本功能？" class="headerlink" title="操作系统的基本功能？"></a>操作系统的基本功能？</h3><ul>
<li>进程管理：进程控制、进程同步、进程通信、死锁处理、处理机调度等</li>
<li>内存管理：内存分配、地址映射、内存保护与共享、虚拟内存等</li>
<li>文件管理：文件存储空间的管理、目录管理、文件读写管理和保护等</li>
<li>设备管理：完成用户的 I&#x2F;O 请求，方便用户使用各种设备，并提高设备的利用率；主要包括缓冲管理、设备分配、设备处理、虛拟设备等</li>
</ul>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><ul>
<li>进程：操作系统分配和管理资源的基本单位；有自己的地址空间，有多个线程</li>
<li>线程：是CPU调度的基本单位；一个进程中的多个线程共享进程资源</li>
</ul>
<h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><ul>
<li>就绪：等待被调度</li>
<li>运行</li>
<li>阻塞：等待资源</li>
</ul>
<h4 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h4><h5 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h5><ul>
<li>先来先服务，first-come first-serverd（FCFS）</li>
<li>短作业优先，shortest job first（SJF）：防止长作业饿死</li>
<li>最短剩余时间优先，shortest remaining time next（SRTN）</li>
</ul>
<h5 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h5><ul>
<li>时间片轮转</li>
<li>优先级调度：给进程设置优先级</li>
<li>多级反馈队列：相当于时间片+优先级</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114575142-e82ac0b6-9669-471c-8d85-dcc43506599c.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9462d5a4&margin=%5Bobject%20Object%5D&name=%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97.png&originHeight=281&originWidth=387&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24188&status=done&style=none&taskId=uc3fc554f-aa71-442a-97a3-fe6a1daa156&title=" srcset="/img/loading.gif" lazyload alt="多级反馈队列.png"><br>每个队列的优先级别都不同，上面的高，下面的低</p>
<h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><h5 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h5><p>对临界资源进行访问的代码块叫做临界区；在同一个时刻，只有一个进程能进入临界区</p>
<h5 id="同步-amp-互斥"><a href="#同步-amp-互斥" class="headerlink" title="同步&amp;互斥"></a>同步&amp;互斥</h5><ul>
<li>同步：多个进程按顺序执行</li>
<li>互斥：多个进程在同一时刻只有一个能进入临界区</li>
</ul>
<h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作</p>
<ul>
<li>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0</li>
<li>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作</li>
</ul>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁</p>
<h4 id="进程间的通信？"><a href="#进程间的通信？" class="headerlink" title="进程间的通信？"></a>进程间的通信？</h4><ul>
<li>无名管道，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系；无名管道的建立就是通过fork()函数（类似克隆）来建立一个子进程，然后父子进程就可以通过管道</li>
<li>有名管道：去除了管道父子进程的限制</li>
<li>消息队列：存放消息的链表，一个存消息，一个读消息</li>
<li>共享内存：最快的通信方式</li>
<li>信号量：控制多个进程对共享资源的访问，比如临界区</li>
<li>Socket：和其它不同，套接字可用于两台不同机器的进程进行通信</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁的必要条件（重点）：</p>
<ul>
<li>互斥：多个进程对资源的访问是互斥的；不可同时占有</li>
<li>占有和等待：已经占有某个资源的进程还可以尝试获取别的资源</li>
<li>不可强占：除非一个进程自己释放资源，其它线程不可强行获取</li>
<li>循环等待：A等B释放资源，B等C释放资源，C等A释放资源</li>
</ul>
<h4 id="破坏死锁"><a href="#破坏死锁" class="headerlink" title="破坏死锁"></a>破坏死锁</h4><p>强制破坏死锁的任一条件；例如强制杀死进程</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><ul>
<li>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</li>
<li>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令</li>
</ul>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul>
<li>最佳置换算法</li>
<li>最近最久未使用，LRU</li>
<li>最近未使用</li>
<li>FIFO先进先出</li>
<li>第二次机会算法</li>
<li>时钟</li>
</ul>
<p>未完待续…</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul>
<li>开闭原则，简称OCP。即软件实体对扩展是开放的，对修改是闭合的</li>
<li>里氏替换原则，简称LSP。即任何父类出现的地方都可以被子类代替</li>
<li>依赖倒转原则，简称DIP。即要依赖于抽象而不要依赖于具体实现</li>
<li>接口隔离原则，简称ISP。即为客户端尽可能提供小的、单独的接口，而不是提供更大的接口</li>
<li>组合&#x2F;聚合复用原则，简称CARP。即尽量使用组合、聚合来达到复用的目的，而不是利用继承</li>
<li>迪米特法则，简称LOD，讲的是一个软件实体应当与尽可能少的其他软件实体发生相互作用</li>
</ul>
<h3 id="挑几个重点的"><a href="#挑几个重点的" class="headerlink" title="挑几个重点的"></a>挑几个重点的</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>标准写法，双重校验 + volatile</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//双重校验，线程安全 [推荐]</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton7</span> &#123;<br>       <span class="hljs-comment">//volatile关键字可以避免instance = new Singleton7()的重排序</span><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton7</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton7</span><span class="hljs-params">()</span> &#123;<br><br>       &#125;<br><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton7 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">synchronized</span> (Singleton7.class) &#123;<br>                   <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)<br>                       instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton7</span>();<br><br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">return</span> instance;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂三兄弟：简单工厂模式，工厂方法模式，抽象工厂</p>
<h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>将处理行为的对象连成一条链，并沿着这条链发送该请求。当前对象的级别不够处理这条请求，就把请求抛给上一级处理</p>
<ul>
<li>拦截器</li>
</ul>
<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>一对多的依赖关系，n个观察者观察一个被观察者，当被观察者的对象发生改变时，消息会通知给所有的观察者</p>
<ul>
<li>微信公众订阅号</li>
</ul>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>想用别人的类，但是又不想改变我原有的设计格式。直接用别人的实例对象，用自己的函数内部嵌套别人的对象.函数</p>
<h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活</p>
<ul>
<li>Java中IO流的设计</li>
</ul>
<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>把被代理的对象拿过来使用，并且在使用前后可以增加一些新的功能<br>和装饰模式的区别？</p>
<ul>
<li>代理，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制</li>
<li>装饰，偏重对原对象功能的扩展，扩展后的对象仍是是对象本身</li>
</ul>
<h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>自己写一个代理模式的那种</p>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>代理类实现InvocationHandler，代理一个已经实现接口的类。通过字节码框架动态生成字节码，并且在defineclass加载类后，获取代理类的实例。代理的是同名的方法</p>
<h5 id="CGlib代理"><a href="#CGlib代理" class="headerlink" title="CGlib代理"></a>CGlib代理</h5><p>也是通过字节码生成框架生成代理类的字节码，不同的是被代理的类不需要实现接口；生成的代理类是业务类的子类，通过重写业务方法进行代理</p>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>如果对象存在，则直接使用。如果不存在，则把他放入对象池中</p>
<ul>
<li>常量池</li>
</ul>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114610141-6503e157-f429-41a5-bdf2-c0fd3c003202.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=290&id=ue7441120&margin=%5Bobject%20Object%5D&name=%E6%8E%92%E5%BA%8F.png&originHeight=325&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21345&status=done&style=none&taskId=ue046904c-c164-428a-be4d-97d41ba97ae&title=&width=494" srcset="/img/loading.gif" lazyload alt="排序.png"></p>
<h3 id="快排什么时候最差？"><a href="#快排什么时候最差？" class="headerlink" title="快排什么时候最差？"></a>快排什么时候最差？</h3><p>快排的效率和选择的基准有很大的关系：</p>
<ul>
<li>如果划分是平衡的，那么快速排序算法性能与归并排序一样</li>
<li>如果划分时不平衡的，那么快速排序的性能就接近于插入排序了</li>
</ul>
<p>导致最差的情况：</p>
<ul>
<li>在分解时每次选取的主元素为最小元素</li>
<li>在分解时每次选取的主元素为最大元素</li>
</ul>
<p>为了防止最差的情况，每次基准随机取值；或者取当前中值：（最大值+最小值）&#x2F;2，这个值不存在就取离中值最近的值</p>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>出自牛客：</p>
<blockquote>
<p>不稳定的排序算法有：快、希、选、堆。（记忆：找到工作就可以“快些选一堆”美女来玩了（并不能））</p>
</blockquote>
<h2 id="数据库和MySQL"><a href="#数据库和MySQL" class="headerlink" title="数据库和MySQL"></a>数据库和MySQL</h2><p>MySQL和数据库理论知识</p>
<h3 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h3><ul>
<li>原子性，不可分割，要么全部提交成功，要么回滚失败</li>
<li>一致性，数据库在执行事务前后从一个状态转化到另一个状态；<strong>一致性主要关注中间数据的可见性，中间状态的数据对外部不可见</strong>，只有最初状态和最终状态的数据对外可见</li>
<li>隔离性，一个事务所做的修改在最终提交以前，对其它事务是不可见的</li>
<li>持久性，一旦事务提交，则其所做的修改将会永远保存到数据库中</li>
</ul>
<h4 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h4><p>隔离性，通过锁来实现的；<br>原子性、一致性和持久性由数据库的 <strong>redo log</strong> 和 <strong>undo log</strong> 实现；redo log：数据缓冲和事务持久，做了哪些操作，都可查<br>事务的回滚和MVCC版本控制，需要undo日志</p>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul>
<li>未提交读，所谓的脏读，A事务还没提交，B事务读到了脏数据</li>
<li>提交读，解决了上一个问题；但是存在着幻读，即不可重复读，A连续读两次，但在读中间B插入修改数据，造成A幻读</li>
<li>可重复读，确保了同一个事务多次读数据能读到同样的数据行；这是MySQL的默认的隔离级别</li>
<li>可串行化，强制事务串行执行，也就不存在并发的问题了，但是效率很低下</li>
</ul>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ljfrocky/article/details/80379328">聊一聊MySQL里的锁和MVCC</a></p>
<h4 id="锁的思想：乐观锁和悲观锁"><a href="#锁的思想：乐观锁和悲观锁" class="headerlink" title="锁的思想：乐观锁和悲观锁"></a>锁的思想：乐观锁和悲观锁</h4><p>两者的区别：</p>
<ul>
<li>乐观锁，不加锁，大多是基于数据的版本号实现的，给每个数据加个版本号，现在A事务提交，若当前版本&gt;数据库已存在的版本，那么可以提交，负责就认为这个数据被别的事务修改过了，回滚；好处是不加锁，性能有所提高，但也有安全隐患</li>
<li>悲观锁：对数据的操作都要加锁，安全度很高，但是性能开销也大</li>
</ul>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MySQL的InnoDB引擎通过MVCC（多版本并发控制）来实现可重复读和读已提交。本质也是通过版本号实现的一种乐观锁。</p>
<h4 id="锁的粒度：表级锁和行级锁"><a href="#锁的粒度：表级锁和行级锁" class="headerlink" title="锁的粒度：表级锁和行级锁"></a>锁的粒度：表级锁和行级锁</h4><p>一般来说，锁的粒度越小，冲突越少，整个系统的并发性越高</p>
<ul>
<li>MyISAM仅支持表级锁</li>
<li>InnoDB引擎支持行级锁</li>
</ul>
<h4 id="真正的锁：共享锁和排它锁"><a href="#真正的锁：共享锁和排它锁" class="headerlink" title="真正的锁：共享锁和排它锁"></a>真正的锁：共享锁和排它锁</h4><ul>
<li>当事务A加了共享锁之后，其它的事务只能加共享锁；持有共享锁的事务，只能读，不能修改数据</li>
<li>当事务A加了排它锁后，只有事务A可以修改和读取数据；其它事务不能加任何锁，直到A释放</li>
</ul>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>采用B+树，查找：在根节点进行二分查找；找不到再递归，在子节点上依次查找，数据结构：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114642953-64d31867-6ed6-4dfd-ba9f-cf27be540869.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u51ab42a1&margin=%5Bobject%20Object%5D&name=B%E5%8A%A0%E6%A0%91.png&originHeight=191&originWidth=543&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12517&status=done&style=none&taskId=u32933ab8-8db8-4af9-b652-9105e5a983c&title=" srcset="/img/loading.gif" lazyload alt="B加树.png"></p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul>
<li>所有的节点为红色或者黑色</li>
<li>根节点和空的叶子节点为黑色</li>
<li>红节点的子节点为黑色</li>
<li>从任意节点到其每个叶子节点的路径经过相同的黑节点(最长路径长度不超过最短路径长度的2倍)</li>
</ul>
<p>红黑树对比B+树：</p>
<ul>
<li>更少的查找次数，相同节点下，B+树的高度更低，查找效率更高</li>
<li>利用磁盘预读特性：操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据，数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I&#x2F;O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/scu-cjx/p/8629215.html">查找树效率对比</a></p>
<h5 id="几种树的查询、删除效率"><a href="#几种树的查询、删除效率" class="headerlink" title="几种树的查询、删除效率"></a>几种树的查询、删除效率</h5><p>二叉搜索树BST：</p>
<ul>
<li>查找效率最好的情况是O(logN)，最差的情况会退化成O(N)</li>
<li>插入和删除仅需要微调或者不调整，时间复杂度和查找差不多</li>
</ul>
<p>平衡二叉树AVL：</p>
<ul>
<li>查询效率最好，O(logN)；因为保证了严格的平衡条件</li>
<li>插入代价：每次只需要旋转一次，因此插入代价也在O(logN)</li>
<li>删除代价很高，必须递归检查是否平衡，时间复杂度在O(2logN)</li>
</ul>
<p>红黑树：<br>介于BST和AVL之间，牺牲插入、删除的代价，来换取O(logN)的查询效率</p>
<ul>
<li>查询效率基本维持在O(logN)，但是最差的情况下会比O(logN)差</li>
<li>插入和删除代价在O(logN)，小于AVL树</li>
<li>Java中TreeMap就是一颗红黑树</li>
<li>插入一个节点最多旋转2次，删除一个节点最多旋转3次</li>
</ul>
<h4 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a>hash索引</h4><p>当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引：</p>
<ul>
<li>只支持精确查找，无法用于部分查找和范围查找</li>
</ul>
<h4 id="聚簇-amp-amp-非聚簇索引"><a href="#聚簇-amp-amp-非聚簇索引" class="headerlink" title="聚簇&amp;&amp;非聚簇索引"></a>聚簇&amp;&amp;非聚簇索引</h4><ul>
<li>聚簇索引指的是数据文件和索引文件是同一个文件，例如InnoDB中表的主键就是聚簇索引；一个表只能有一个聚簇索引</li>
<li>非聚簇索引，索引中存放的不是数据本身，而是指向数据地址的指针；主要用于MyISAM存储引擎中</li>
</ul>
<h4 id="主键索引和非主键索引"><a href="#主键索引和非主键索引" class="headerlink" title="主键索引和非主键索引"></a>主键索引和非主键索引</h4><p>主键索引和非主键索引是有区别的：<br>主键索引存放的值是<strong>整行字段的数据</strong><br>非主键索引上存放的值不是整行字段的数据，而且<strong>存放主键字段的值</strong>，因此非主键索引要走两遍扫描，第一次扫描出主键，再走主键索引</p>
<h4 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h4><ol>
<li>当一个字段更新频率较低，但查询频率较高，建议使用索引</li>
<li>经常同时存取多列，可以考虑使用组合索引</li>
<li>组合索引的前导列如果不在查询条件中则该索引不会被使用</li>
</ol>
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><ul>
<li><p>直接索引和间接索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>直接索引<br><span class="hljs-keyword">create</span> index name1_index <span class="hljs-keyword">on</span> table1(column1)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>间接索引：定义主键或者唯一性约束，可以自动创建索引<br></code></pre></td></tr></table></figure>
</li>
<li><p>唯一性索引：保证索引列中的数据都是唯一的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> coustered index name2_index <span class="hljs-keyword">on</span> table1(column1)<br></code></pre></td></tr></table></figure>
</li>
<li><p>组合&#x2F;复合索引：对多个字段进行联合创建索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index name3_index <span class="hljs-keyword">on</span> table1(column1,column2)<br></code></pre></td></tr></table></figure>
</li>
<li><p>聚簇索引和非聚簇索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> coustered index name2_index <span class="hljs-keyword">on</span> table1(column1)<br><span class="hljs-keyword">create</span> uncoustered index name2_index <span class="hljs-keyword">on</span> table1(column1)<br></code></pre></td></tr></table></figure></li>
</ul>
<h5 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h5><ul>
<li>查询条件中含有or</li>
<li>对于组合索引，若第一列不在查询条件中</li>
<li>like以%开头</li>
<li>如果列类型是字符串，查询条件的时候没有用单引号引起来</li>
<li>MySQL 引擎认为全表扫描比索引更快的情况</li>
<li>where中有表达式，函数等</li>
</ul>
<p>比如<code>where c - 1 = 1000</code>，这样导致索引失效；改为<code>where c = 1000 + 1</code>；<br>还有用了一些函数导致索引失效</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>MySQL的两个存储引擎MyISAM和InnoDB：</p>
<ul>
<li>InnoDB是事务安全的，MyISAM不是</li>
<li>InnoDB支持行级锁，而MyISAM仅表锁</li>
<li>索引的区别，聚簇和非聚簇</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>MyISAM，它管理非事务的表，提供高速的存储和检索，以及全文的搜索能力，如果场景下查询的业务很多，大量的select语句，那么MyISAM是更好的选择</p>
<p>InnoDB用于事务处理应用程序，如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能</p>
<h3 id="常用的SQL"><a href="#常用的SQL" class="headerlink" title="常用的SQL"></a>常用的SQL</h3><h4 id="几种删除的区别"><a href="#几种删除的区别" class="headerlink" title="几种删除的区别"></a>几种删除的区别</h4><ul>
<li>drop：删除表</li>
<li>truncate：清空表的数据，表本身还在</li>
<li>delete：删除表的某些数据，配合where做筛选</li>
</ul>
<h4 id="几种连接的区别"><a href="#几种连接的区别" class="headerlink" title="几种连接的区别"></a>几种连接的区别</h4><ul>
<li><p>内连接：将两个表取交集，会忽略掉两个表对应不起来的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.xxx<span class="hljs-operator">=</span>table2.xxx<br></code></pre></td></tr></table></figure>
</li>
<li><p>左连接：left左边的表取全部数据，右边的表缺少的数据补NULL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.xxx<span class="hljs-operator">=</span>table2.xxx<br></code></pre></td></tr></table></figure>
</li>
<li><p>右连接：和左连接相反</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.xxx<span class="hljs-operator">=</span>table2.xxx<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Linux指令"><a href="#Linux指令" class="headerlink" title="Linux指令"></a>Linux指令</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>创建用户并生成对应的home文件夹：<br>useradd -d &#x2F;home&#x2F;zc -m zc</p>
<p>修改用户密码：<br>passwd zc</p>
<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看kafka对应的进程号<br>ps aux | grep kafka<br>ps -ef | grep kafka</p>
<p>查看端口对应的进程号<br>lsof  -i:9092</p>
<p>根据进程号查看对应的信息，比如端口啥的<br>netstat -anop | grep PID</p>
<p>根据进程号杀死进程<br>kill -9 21804</p>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/135411.htm">top命令详解</a><br>top 命令主要用于查看进程的相关信息，同时它也会提供系统平均负载，cpu 信息和内存信息：</p>
<ul>
<li>系统平均负载</li>
<li>任务信息汇总</li>
<li>CPU信息</li>
<li>内存信息</li>
<li>任务详情</li>
</ul>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>ping是探测主机和主机之间能否通信；使用的是ICMP协议-&gt;IP协议</p>
<p>ICMP协议规定：目的主机必须返回ICMP包给源主机，如果在一定时间内没有返回，则认为目的主机不可达；IP协议是无连接的、不可靠的数据报协议</p>
<h4 id="ping-192-168-1-5的细节过程？"><a href="#ping-192-168-1-5的细节过程？" class="headerlink" title="ping 192.168.1.5的细节过程？"></a>ping 192.168.1.5的细节过程？</h4><ol>
<li>生成ICMP报文，交给IP层处理，IP层再将源主机和目的主机的地址打包+控制信息，生成IP报文</li>
<li>然后需要找到目的地址的MAC地址；先去ARP缓存去找，找不到则广播，获取MAC地址（找不到则返回超时信息）</li>
<li>再将MAC地址封装成数据链路包，交给数据链路层；发送给目的地址</li>
<li>目的地址收到报文，再以相同的方式返回给源地址</li>
</ol>
<p>ARP协议：存放了IP地址到MAC地址的映射</p>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>侦测由源主机到目的主机所经过的路由的情况的重要工具；ping受到IP头的限制（IP首部字段最多只能放9个IP地址），ping不能完全记录所经过的路由器</p>
<p>Traceroute原理：</p>
<ol>
<li>首先给目的主机发送一个TTL&#x3D;1（TTL指生存时间）的udp数据包，而经过的第一个路由器收到这个数据包之后，自动把TTL减去1，而TTL变为0之后，路由器就将这个数据包抛弃，并同时产生一个主机不可达的ICMP超时数据报给主机</li>
<li>主机收到这个ICMP数据报以后，会发送一个TTL&#x3D;2的数据报给目的主机，然后刺激第二个路由器给主机发送ICMP数据报，如此反复，直到到达目的主机。这样Traceroute就可以拿到所有路由器的IP</li>
</ol>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="category-chain-item">面试总结</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%A0%A1%E6%8B%9B/">#校招</a>
      
        <a href="/tags/Java/">#Java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java 面试总结</div>
      <div>http://zhangchaozc.cn/2021/01/23/面试总结/Java-面试总结/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>积极向上好青年</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年1月23日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01/24/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" title="大数据面试总结">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">大数据面试总结</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/08/17/Linux/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84-Linux-%E5%91%BD%E4%BB%A4/" title="一些常用的 Linux 命令">
                        <span class="hidden-mobile">一些常用的 Linux 命令</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'http://zhangchaozc.cn/2021/01/23/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/';
          this.page.identifier = '/2021/01/23/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

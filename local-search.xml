<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大数据面试总结</title>
    <link href="/2021/01/24/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/24/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h1><h2 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h2><p>分布式系统不可能同时满足一致性、可用性和分区容忍性，最多只能满足其中的两项</p><ul><li>Consistency一致性：指的是多个副本能否保持一致；对某个数据进行更新后，如果所有用户都能读取到最新的值，那么认为该系统具有强一致性</li><li>Availability可用性：系统在面对各种异常时可以提供正常服务的能力，&#x3D; 系统可用时间 &#x2F; 总时间，4 个 9 的可用性表示系统 99.99% 的时间是可用的</li><li>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信</li></ul><h2 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h2><p>远程过程调用。<br>两个不同的进程，一个如何调用另一个的函数？基于socket的网络传输，将需要调用的类，方法，参数通过socket传输到另一个进程上。通过反射机制生成实例，再调用函数</p><h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><p>Hadoop生态<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114741379-0a3f9138-107e-452e-a38d-14833856f930.png#clientId=ua8a8020e-04b7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u53391230&margin=%5Bobject%20Object%5D&name=Hadoop%E7%94%9F%E6%80%81.png&originHeight=716&originWidth=1076&originalType=binary&ratio=1&rotation=0&showTitle=false&size=212658&status=done&style=none&taskId=u72ccfe53-fd03-4ef2-9672-3034006aa35&title=" alt="Hadoop生态.png"></p><h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><p>主从结构，只有一个NameNode，有很多DataNode<br>NameNode：接收用户的操作请求；维护文件系统的目录结构；管理文件与block之间的关系，block与DataNode之间的关系；存储元数据，元数据保存在内存中<br>DataNode：文件被分为block存储在磁盘上，有多个副本；存储文件内容，保存在磁盘中<br>NameNode的离线备份：SecondaryNameNode<br>文件切分为块，默认大小每个版本不一样，可配置；副本数量默认为3，可配置<br>DataNode通过心跳机制（周期为3秒，可配置）和NameNode进行联系，除了发送心跳包以外，还发一些信息等<br>分布式文件系统：</p><ul><li>通透性，让用户看起来就是像访问磁盘一样</li><li>容错性，某个节点的宕机不影响整个系统的运作</li></ul><p>在Hadoop中，有一个文件系统的抽象，它提供了文件系统实现的各类接口，HDFS只是这个抽象文件系统的一个实例：org.apache.hadoop.fs.FileSystem<br>心跳每3秒一次，如果超过10分钟没有收到某个DataNode 的心跳，则认为该节点不可用。伴随DataNode的心跳，还发送有块报告，包含datanode上所有数据块的列表。NameNode回复心跳，也伴随着相关指令等<br>特点：</p><ul><li>适合处理大文件，不适合处理小文件</li><li>不适合处理低延迟数据访问，适合离线任务</li><li>设计原则是“一次写入，多次读取”，因此不适合存储修改频繁的文件</li></ul><p>常用命令：<br>hadoop fs -ls &#x2F; ：列出所有文件<br>hadoop fs -put ：将本地文件上传到HDFS<br>hadoop fs -get ：将HDFS的文件下载到本地</p><h3 id="读写文件流程？"><a href="#读写文件流程？" class="headerlink" title="读写文件流程？"></a>读写文件流程？</h3><ul><li>写文件</li></ul><ol><li>请求先到文件系统，写<strong>操作日志</strong></li><li>文件系统向<strong>NameNode发出RPC调用</strong>，创建文件。NameNode进行权限认证；文件系统新建FSDataOutputStream来处理通信</li><li>FSDataOutputStream把文件分包，放入数据队列；数据队列由DataStreamer处理，为数据包挑选合适的datanode，被选中的datanode和数据包之间形成管道pipeline</li><li>通过流的方式，把数据送过去；同时也维护一个ack队列，用来确认包是否都送达</li><li>全部送完后，客户通知文件写入完毕</li></ol><ul><li>读文件</li></ul><ol><li>通过文件系统打开文件</li><li>文件系统通过RPC请求namenode，确定文件在哪个块上</li><li>找到后新建FSDataInputStream开始读数据</li><li>先读完第一个块，随后读取其它的块，直到全部读完</li></ol><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>JobTracker：接收计算任务；将任务分给TaskTrackers执行；监控执行情况TaskTracker：执行任务<br>实现map()和reduce()两个函数，即可实现分布式计算；无需考虑分布式计算的底层细节如：网络通信、任务分发、任务调度等<br>map任务：</p><ol><li>读取文件内容，解析成key-value对，每一个键值对调用一次map函数</li><li>写map函数，对key-value进行处理，转化为新的key-value输出</li><li>对key-value分区，对不同key排序分组（可选）</li></ol><p>reduce任务：</p><ol><li>通过网络获取map的key-value对，将相同key的数据group起来</li><li>写reduce函数，将输入的key-value对转化成新的key-value输出</li></ol><p>入门基础例子：WordCount文件：<br>hadoop hdfs<br>hadoop spark<br>hadoop mapreduce<br>map:输入：(k,”hadoop hdfs”) &#x3D;&gt; (“hadoop”,1)，k为行号所在的字符偏移<br>reduce：输入：(“hadoop”,list(1,1,1)) &#x3D;&gt; (“hadoop”,3) &#x3D;&gt; 写文件</p><h3 id="combine方法"><a href="#combine方法" class="headerlink" title="combine方法"></a>combine方法</h3><p>在reduce之前先在本地先combine一下，减少reduce的数。某些情况下combine函数和自己写的mapper函数是一样的</p><h3 id="partition方法"><a href="#partition方法" class="headerlink" title="partition方法"></a>partition方法</h3><p>根据key来分区，也就是输出分文件输出</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>MapReduce的输入被分为很多InputSplit，每个InputSplit是输入的其中一块数据，每个Mapper处理一个InputSplit；每个InputSplit被分为多条record，每个record产生一个key-value对<br>流程：</p><ul><li>当客户端运行一个Job时，客户端调用getSplits方法，将InputSplit列表发送给jobTracker</li><li>map task会将split传递给recordReader</li><li>recordReader会一次读取一条记录，产生key-value传递给map方法</li><li>map里面的run方法会不停的调用nextKeyValue()</li><li>通过上下文对象调用recordReader中的同名方法</li><li>context.getCurrentKey()和context.getCurrentValue()调用都会委托给recordReader中的同名方法</li></ul><p>默认的输入类是TextInputFormat，默认读一行数据，还有其它的输入类：</p><ul><li>NLineInputFormat</li><li>BinaryInputFormat</li><li>DBInputFormat</li><li>等</li></ul><p>同理，输出默认为TextOutputFormat，也有其它的输出类</p><h4 id="数据倾斜？"><a href="#数据倾斜？" class="headerlink" title="数据倾斜？"></a>数据倾斜？</h4><p>数据倾斜指的是大量相同的Key被partition分配到同一个分区中，导致一个节点很忙碌，而其它节点很闲；使得总体的效率非常低下<br>解决办法</p><ul><li>增加JVM内存（治标不治本）</li><li>增加Reduce的个数（还是没有根本的解决问题）</li><li>自定义分区，自己写一个partition类用来分区（可取）</li><li>重新设计Key，在map阶段给Key加一个随机数，reduce阶段再去掉（可用）</li><li>使用combinner合并，combinner是在map阶段、reduce之前的一个中间阶段，在这个阶段可以选择性的把大量的相同key数据先进行一个合并，减轻reduce的工作（可用）</li></ul><h3 id="MR的Shuffle和Spark的Shuffle"><a href="#MR的Shuffle和Spark的Shuffle" class="headerlink" title="MR的Shuffle和Spark的Shuffle"></a>MR的Shuffle和Spark的Shuffle</h3><p><a href="https://www.jianshu.com/p/ba2c67897fc1">https://www.jianshu.com/p/ba2c67897fc1</a><br>从Map端输出K-V，到Reduce端接收K-V，整个中间的过程可以称之为Shuffle；Shuffle分为两个部分：<br>Map端：</p><ol><li>在map task执行时，它的输入数据来源于HDFS的block，假设map的输入数据都是像”aaa”这样的字符串</li><li>key是”aaa”， value是数值1；假设现在有3个reducer，key交给哪个去处理？默认对key hash后再以reduce task数量取模，从而确定；当然，有提供Partitioner接口，可以自定义这个逻辑</li><li>key与value值都会被序列化成字节数组写入到Map端缓冲区，缓冲区是为了减少对磁盘的IO操作；然而，缓冲区的大小默认是100M，当缓冲区快满（达到了80%）的时候，数据会被写入磁盘中的临时文件（这个过程叫做Spill）</li><li>溢写前会对数据进行排序，如果客户端设置了combine函数，会把相同的key做个累加，以减少溢写到文件中的K-V数量</li><li>多次溢写会产生多个临时文件，包括最后一次执行的缓冲区，会产生若干文件；需要将所有文件合并到一起，这个过程就叫做Merge。对于”aaa”就是像这样的：{“aaa”, [5, 8, 2, …]}</li></ol><p>Reduce端：将Map端的文件拉取过来，作为输入文件</p><h1 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h1><p>引入背景：hadoop1.0中，JobTracker负载太重（既要负责任务的管理，也要负责任务的计算），而且存在单点故障，一旦故障，所有执行的任务全部失败；扩展性差，不支持MR以外的计算；<br>根本思想：根本的思想是将JobTracker两个主要的功能分离成单独的组件，这两个功能是资源管理和任务调度、监控<br>基本架构：<br>ResourceManager：处理请求；启动和监控ApplicationMaster；资源的分配与调度<br>NodeManager：单个节点上的资源管理；处理ResourceManager和ApplicationMaster的命令<br>ApplicationMaster：数据切分；为应用程序申请资源；分配任务、任务监控</p><h1 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h1><h2 id="Flink架构"><a href="#Flink架构" class="headerlink" title="Flink架构"></a>Flink架构</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/svg/22879930/1653114773290-02e943fc-c2b7-49d6-b052-e533bb0eb7a3.svg#clientId=ua8a8020e-04b7-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=421&id=u792f9a06&margin=%5Bobject%20Object%5D&name=Flink%E6%9E%B6%E6%9E%84.svg&originHeight=613&originWidth=851&originalType=binary&ratio=1&rotation=0&showTitle=false&size=78238&status=done&style=none&taskId=u6ff9c5d4-4542-4345-a652-a80984615e4&title=&width=584" alt="Flink架构.svg"><br>典型的主从结构：</p><ul><li>JobManager，管理者，提供：</li></ul><p><strong>ResourceManager</strong> ：负责 Flink 集群中的资源提供、回收、分配 - 它管理 <strong>task slots</strong><br>Flink 为不同的环境和资源提供者（例如 YARN、Mesos、Kubernetes 和 standalone 部署）实现了对应的 ResourceManager<br><strong>Dispatcher</strong> ： 提供了一个 REST 接口，用来提交 Flink 应用程序执行，并为每个提交的作业启动一个新的 JobMaster<br><strong>JobMaster</strong> ： 负责集群的管理，包括：</p><ul><li>资源管理</li><li>Job调度和安排</li><li>Checkpoint管理</li><li>JobGraph，执行图管理</li></ul><p><strong>TaskManager</strong>：负责资源的提供<br>资源调度的最小单位是 task _slot_。TaskManager 中 task slot 的数量表示并发处理 task 的数量。请注意一个 task slot 中可以执行多个算子<br>每个 worker（TaskManager）都是一个 <em>JVM 进程</em><br>注意：slot 是资源管理的最小单位，是有多个线程的</p><ul><li>Shuffle管理。<strong>Shuffle本质是数据在不同的节点中，传输和交换的过程</strong></li></ul><h2 id="Flink和Spark-Streaming区别？"><a href="#Flink和Spark-Streaming区别？" class="headerlink" title="Flink和Spark Streaming区别？"></a>Flink和Spark Streaming区别？</h2><p>设计理念不一样，Spark主要是批处理，它认为流是一种特殊的批次。Spark Streaming 是微批处理，运行的时候需要指定批处理的时间，每次运行 job 时处理一个批次的数据<br>Flink主要是流处理，当然也可以进行批处理（认为批是一种特殊的流）。更适合处理流数据，支持多种时间：事件时间、处理时间</p><h2 id="为什么是Flink？"><a href="#为什么是Flink？" class="headerlink" title="为什么是Flink？"></a>为什么是Flink？</h2><p>Apache Flink是一个面向分布式数据流处理和批量数据处理的开源计算平台，提供支持<strong>流处理</strong>和<strong>批处理</strong>两种类型应用的功能<br>Flink是完全支持流处理，当处理流数据时，数据被定义为是无界的；而批处理作为一种特殊的流处理，输入数据流被定义为有界的<br>从目前来看，有状态的流计算架构模式，只有Flink满足。具体优势有以下几点：</p><ol><li>同时支持高吞吐、低延迟、高性能</li><li>支持事件时间的概念。使用事件产生的时间，基于事件驱动的机制，即使事件乱序到达，流系统也能保证计算出正确的结果</li><li>支持有状态的计算</li><li>支持高灵活的窗口操作。在流数据处理中，数据是连续不断的，需要通过串口的方式对流数据进行一定范围的聚合计算</li><li>基于轻量级的分布式快照，主要是容错，当系统发生故障时，能够快速的从快照中恢复</li></ol><p>应用场景：<br>（1） 实时智能推荐（满足对时延的要求）<br>（2） 复杂事件处理<br>（3） 实时欺诈检测<br>（4） 实时数仓与ETL<br>（5） 流数据分析<br>（6） 实时报表分析</p><h2 id="水位和时间？"><a href="#水位和时间？" class="headerlink" title="水位和时间？"></a>水位和时间？</h2><p>时间概念，是处理时间还是事件时间？以前直接设置<br>env.setStreamTimeCharacteristic();<br>现在最新版本已经废弃了，现在直接指定时间就好了assignTimestampsAndWatermarks<br>用到什么时间，就指定就好了。比如说你用的对象，里面有时间字段，直接指定这个字段为时间就行<br>水位：<br>最新的版本叫做水位策略，数据是流，源源不断的到来，这是一个不确定的东西。水位就是要把不确定变为确定，现在的版本直接指定延迟时间就行了forBoundedOutOfOrderness。当前数据来了之后，携带一个水位信息，比如延迟2秒，当前是第10秒的数据来了，携带的水位是8，会告诉系统8秒以前的数据都到齐了<br>可以看它的代码实现：<br>就是当前emitWatermark等于当前最大的事件时间减去延迟减1<br>在上游有多个输入的流，当前水位取最小的</p><h2 id="什么是有状态的流计算？"><a href="#什么是有状态的流计算？" class="headerlink" title="什么是有状态的流计算？"></a>什么是有状态的流计算？</h2><p>两个概念：状态和状态后端<br>Flink提供了以下几种状态：<br>ValueState<T> getState(ValueStateDescriptor<T>)<br>ReducingState<T> getReducingState(ReducingStateDescriptor<T>)<br>ListState<T> getListState(ListStateDescriptor<T>)<br>AggregatingState&lt;IN, OUT&gt; getAggregatingState(AggregatingStateDescriptor&lt;IN, ACC, OUT&gt;)<br>MapState&lt;UK, UV&gt; getMapState(MapStateDescriptor&lt;UK, UV&gt;)<br>状态后端：<br>可以指定这些变量的状态后端，Flink支持三种：</p><ul><li>MemoryStateBackend ，堆内存，较小，用于<strong>本地调试</strong></li><li>FsStateBackend ，堆内存，受制于GC</li><li>RocksDBStateBackend ，本地磁盘，慢10倍</li></ul><p>当你对这些变量进行操作时，在算子内，这些变量具有<strong>全局可见性</strong>（为什么可以保存上一次的计算结果）<br>这是一种用法<br>另外，当checkpoint到来时（内存屏障），系统会把这些变量dump到本地的文件系统中。（需要你在yaml配置文件中配置checkpoint、savepoint的地址，比如HDFS的地址）<br>以便重启任务可以恢复状态<br>怎么做的：<br>FromElementsFunction的实现，一个有状态的计算<br>一般的做法，就是屏障来的时候，把内存变量放到state中。程序启动时再从state恢复到内存中</p><h2 id="Checkpoint机制？"><a href="#Checkpoint机制？" class="headerlink" title="Checkpoint机制？"></a>Checkpoint机制？</h2><p>内存屏障：<br><img src="https://cdn.nlark.com/yuque/0/2022/svg/22879930/1653114817284-38d7d6c3-0fe8-4d39-9dc4-074ca3d4d308.svg#clientId=ua8a8020e-04b7-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u37bf7c00&margin=%5Bobject%20Object%5D&name=checkpoint%E6%9C%BA%E5%88%B6.svg&originHeight=200&originWidth=553&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15460&status=done&style=none&taskId=u7db3b7ec-a05b-48ff-a453-cd80865346f&title=" alt="checkpoint机制.svg"><br>如果开启checkpoint，流数据会被插入checkpoint屏障，根据你配置的间隔时间插入<br>当checkpoint屏障来的时候，做一些操作，比如：存状态变量等<br>当一个屏障，从source、transform、sink流出，一次checkpoint就结束了<br>上代码：<br>FlinkKafkaConsumer的实现：<br>@Public<br>public interface CheckpointedFunction {<br>&#x2F;**<br>checkpoint 到来时，会调用这个函数<br>*&#x2F;<br>void snapshotState(FunctionSnapshotContext context) throws Exception;</p><pre><code class="hljs">/**程序初始化的时候，启动的时候，如果开启了 checkpoint，会调用这个函数 */void initializeState(FunctionInitializationContext context) throws Exception;</code></pre><p>}</p><p>@Public<br>public interface CheckpointListener {<br>&#x2F;**<br>当一次 checkpoint 完成之后，会调用这个函数<br>*&#x2F;<br>void notifyCheckpointComplete(long checkpointId) throws Exception;</p><p>default void notifyCheckpointAborted(long checkpointId) throws Exception {}<br>}</p><h2 id="Checkpoint和Savepoint的区别？"><a href="#Checkpoint和Savepoint的区别？" class="headerlink" title="Checkpoint和Savepoint的区别？"></a>Checkpoint和Savepoint的区别？</h2><p>官方文档的一句话，checkpoint相当于MySQL的操作日志，savepoint相当于MySQL的备份<br>都是保存数据，对整体和对局部，手动触发和自动触发的区别</p><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="为什么使用MQ？优缺点？"><a href="#为什么使用MQ？优缺点？" class="headerlink" title="为什么使用MQ？优缺点？"></a>为什么使用MQ？优缺点？</h2><p>无非是三个关键字：</p><ul><li>异步</li><li>削峰</li><li>解耦</li></ul><p>异步：<br>对于后台系统，用户一个请求可能需要做很多事情（对接各种系统），用户等待的时间太长了。把消息放队列中，然后再慢慢的去做<br>对于大数据：<br>解耦：<br>总线模块和计算模块分开。数据源只关注有无Kafka，计算的输出可以当做下次计算的输入<br>削峰：<br>数据量峰值很大，也不会引起下游入库的宕机。有消息队列在，慢慢写</p><p><strong>缺点：</strong><br>所有的系统，都依赖它。保证MQ是高可用的。系统维护度、复杂度会变高<br><strong>常用的MQ：</strong></p><ul><li>10w级别的：Kafka，RocketMQ</li><li>1w级别的：ActiveMQ，RabbitMQ</li></ul><h2 id="Kafka如何做到高可用？"><a href="#Kafka如何做到高可用？" class="headerlink" title="Kafka如何做到高可用？"></a>Kafka如何做到高可用？</h2><p>架构图：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114862184-99a607b1-41a0-44c7-b6e0-41646b573291.png#clientId=ua8a8020e-04b7-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=265&id=udb886aef&margin=%5Bobject%20Object%5D&name=kafka%E6%9E%B6%E6%9E%84%E5%9B%BE.png&originHeight=376&originWidth=819&originalType=binary&ratio=1&rotation=0&showTitle=false&size=214381&status=done&style=none&taskId=uda7c8c21-e03e-472c-9dd6-8df394680cd&title=&width=578" alt="kafka架构图.png"></p><ul><li>Kafka由多个broker组成（服务器，一个节点上可以有多个，每个都要配置端口和自己的日志目录）</li><li>创建一个topic，每个topic划分成多个partition分布在不同的broker上</li></ul><p>你可以指定topic有几个副本。假设有3副本，其中1个leader，两个follower<br><strong>写数据</strong>的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）<br><strong>消费</strong>的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到<br>如果某台节点宕机，剩下的follower再选举出一个leader。用来接收读写请求。做到高可用</p><h2 id="Zookeeper有什么用？"><a href="#Zookeeper有什么用？" class="headerlink" title="Zookeeper有什么用？"></a>Zookeeper有什么用？</h2><p>一句话：负责集群的协调和稳定</p><ul><li>比如说一个节点宕机后的选取工作</li></ul><p>Kafka 使用 ZooKeeper ：</p><ul><li>存放集群元数据</li><li>成员管理</li><li>选举</li><li>消费状态，offset管理，消费组管理</li></ul><h2 id="什么是消费组？"><a href="#什么是消费组？" class="headerlink" title="什么是消费组？"></a>什么是消费组？</h2><p>Kafka 中，消费者组是一个由多个消费者实例 构成的组。多个实例共同订阅若干个主题，实现<strong>共同消费</strong>。同一个组下的每个实例都配置有 相同的组 ID，被分配不同的订阅分区。当某个实例挂掉的时候，其他实例会自动地承担起 它负责消费的分区</p><h2 id="Kafka中offset的作用？怎么保证数据有序？"><a href="#Kafka中offset的作用？怎么保证数据有序？" class="headerlink" title="Kafka中offset的作用？怎么保证数据有序？"></a>Kafka中offset的作用？怎么保证数据有序？</h2><p>在 Kafka 中，每个 主题分区下的每条消息都被赋予了一个唯一的 ID 数值，用于标识它在分区中的位置。这个 ID 数值，就被称为位移，或者叫偏移量。一旦消息被写入到分区日志，它的位移值将不能 被修改<br>kafka每个partition中的消息在写入时都是有序的，消费时，<strong>每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序</strong>的。整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1.<br>消费者提交消费位移时提交的是当前消费到的最新消息的offset+1</p><h2 id="为什么Kafka不支持读写分离？"><a href="#为什么Kafka不支持读写分离？" class="headerlink" title="为什么Kafka不支持读写分离？"></a>为什么Kafka不支持读写分离？</h2><p>在 Kafka 中，生产者写入消息、消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种<strong>主写主读</strong>的生产消费模型</p><ul><li>延时导致的数据一致性问题。同步需要时间，这个时候去读副本，可能是脏数据</li></ul><h2 id="Kafka怎么保证数据不重复？"><a href="#Kafka怎么保证数据不重复？" class="headerlink" title="Kafka怎么保证数据不重复？"></a>Kafka怎么保证数据不重复？</h2><p>什么情况下数据会重复消费？数据被消费了，被处理了，但是还没有提交offset，这个时候挂了<br>再次重启消费，数据就重复了。怎么办？</p><ol><li>数据的输出是否是幂等的，比如有主键，即使重复产生了数据，也不会写两次。因为会主键冲突，我们只要判断一下是否存在，存在则更新</li><li>双写数据库，比如已经消费的数据，另写一份到外部存储，比如Redis。每次只要判断Redis中是否有即可，这样不会保存重复的数据</li></ol><h2 id="Kafka怎么保证数据不丢？"><a href="#Kafka怎么保证数据不丢？" class="headerlink" title="Kafka怎么保证数据不丢？"></a>Kafka怎么保证数据不丢？</h2><p>常见的场景：</p><ol><li>数据还没处理完，offset自动提交了，在消费端数据丢了。解决办法：关闭Kafka的自动提交的策略，处理完数据后手动提交</li><li>在发送端丢了，数据发到leader，还没同步，系统挂了</li></ol><p>回复Ack：<br>分为两个，一是leader收到了，就认为成功发送；二是所有的副本都同步了，才认为数据成功发送。<br>设置ack&#x3D;all，副本都同步了，才算成功<br>此外：</p><ul><li>设置 replication.factor 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本</li><li>在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧</li></ul><h2 id="MQ消息过期？消息积压？怎么处理"><a href="#MQ消息过期？消息积压？怎么处理" class="headerlink" title="MQ消息过期？消息积压？怎么处理"></a>MQ消息过期？消息积压？怎么处理</h2><p>消息过期了，导致数据丢了？批量重导入，从业务数据再导入到MQ，补上<br>消息积压：</p><ul><li>提高消费者的并行度，临时新建一个topic，扩partition为原来的10倍（可以支持并行度是原来的10倍）</li><li>把旧topic数据搬到新topic，再以10倍的速度进行消费</li></ul><h1 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h1><p>进阶知识合集<br><a href="https://github.com/doocs/advanced-java">进阶面试连环炮</a></p><h2 id="JVM调优问题"><a href="#JVM调优问题" class="headerlink" title="JVM调优问题"></a>JVM调优问题</h2><h3 id="基本的参数知识"><a href="#基本的参数知识" class="headerlink" title="基本的参数知识"></a>基本的参数知识</h3><p>JVM参数，标准参数：<br>java -help<br>java -server<br>java -client<br>java -version<br>java -help<br>java -help<br><strong>标准参数一般在各个版本中都是稳定不变的</strong><br>X参数，非标准化参数：<br>java -Xint：完全解释执行<br>java -Xcomp：第一次使用就编译成本地代码（完全编译执行）<br>java -Xmixed：混合模式，JVM自己来决定是否编译成本地代码<br>XX参数：<br>java -XX:[+-]<name>表示启用或者禁用某个属性</p><h1 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h1><p>java -XX:+UseG1GC 使用G1垃圾收集器</p><h1 id="kv对"><a href="#kv对" class="headerlink" title="kv对"></a>kv对</h1><p>java -XX:<name>&#x3D;<value> KV类型，设置Key-Value属性对<br>常用，设置最大堆，最小堆</p><p>简写<br>-Xmx和-Xms：<br>-Xms等价于：-XX:InitialHeapSize，初始堆大小<br>-Xmx等价于：-XX:MaxHeapSize，最大堆大小</p><h3 id="查看当前的JVM参数"><a href="#查看当前的JVM参数" class="headerlink" title="查看当前的JVM参数"></a>查看当前的JVM参数</h3><p>直接打印出当前JVM的配置参数：</p><blockquote><p>java -XX:+PrintFlagsFinal &gt; D:&#x2F;jvm_param.txt<br>一部分内容：</p></blockquote><p>&#x3D; 代表就是默认值没有变<br>:&#x3D; 代表是修改过的值</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">intx <span class="hljs-built_in">CICompilerCount</span>                          := <span class="hljs-number">4</span>                                   &#123;product&#125;      <span class="hljs-type">bool</span> <span class="hljs-built_in">CICompilerCountPerCPU</span>                     = <span class="hljs-literal">true</span>                                &#123;product&#125;      <span class="hljs-type">bool</span> <span class="hljs-built_in">CITime</span>                                    = <span class="hljs-literal">false</span>                               &#123;product&#125;      <span class="hljs-type">bool</span> <span class="hljs-built_in">CMSAbortSemantics</span>                         = <span class="hljs-literal">false</span>                               &#123;product&#125;     uintx <span class="hljs-built_in">CMSAbortablePrecleanMinWorkPerIteration</span>   = <span class="hljs-number">100</span>                                 &#123;product&#125;      intx <span class="hljs-built_in">CMSAbortablePrecleanWaitMillis</span>            = <span class="hljs-number">100</span>                                 &#123;manageable&#125;     uintx <span class="hljs-built_in">CMSBitMapYieldQuantum</span>                     = <span class="hljs-number">10485760</span>                            &#123;product&#125;<br></code></pre></td></tr></table></figure><p><strong>查看当前进程的JVM参数：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean"># <span class="hljs-number">1.</span> jps，找到 pid，假设为 <span class="hljs-number">16024</span> # <span class="hljs-number">2.</span> 查看堆内存大小，查看是否使用了 G1 jinfo -flag MaxHeapSize <span class="hljs-number">16024</span> # -XX:MaxHeapSize=<span class="hljs-number">4127195136</span> jinfo -flag UseG1GC <span class="hljs-number">16024</span> # -XX:-UseG1GC，- 减号代表没用<br></code></pre></td></tr></table></figure><h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><p>每 3 秒输出一次 GC 信息<br>C:\Users\zhangchao&gt;jstat -gc 16024 3000  S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT 10240.0 10240.0  0.0    0.0   63488.0   6382.3   167936.0     0.0     4480.0 770.2  384.0   75.9       0    0.000   0      0.000    0.000 10240.0 10240.0  0.0    0.0   63488.0   6382.3   167936.0     0.0     4480.0 770.2  384.0   75.9       0    0.000   0      0.000    0.000 10240.0 10240.0  0.0    0.0   63488.0   6382.3   167936.0     0.0     4480.0 770.2  384.0   75.9       0    0.000   0      0.000    0.000 # 显示堆中各区域大小，但是不太直观<br>每 3 秒输出一次 GC 信息（比例信息）<br>C:\Users\zhangchao&gt;jstat -gcutil 16024 3000   S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT   0.00   0.00  10.05   0.00  17.19  19.76      0    0.000     0    0.000    0.000   0.00   0.00  10.05   0.00  17.19  19.76      0    0.000     0    0.000    0.000   0.00   0.00  10.05   0.00  17.19  19.76      0    0.000     0    0.000    0.000   0.00   0.00  10.05   0.00  17.19  19.76      0    0.000     0    0.000    0.000   0.00   0.00  10.05   0.00  17.19  19.76      0    0.000     0    0.000    0.000   0.00   0.00  10.05   0.00  17.19  19.76      0    0.000     0    0.000    0.000<br>变量解释：<br>NGCMN：新生代最小容量 NGCMX：新生代最大容量 NGC：当前新生代容量 S0C：第一个幸存区大小 S1C：第二个幸存区的大小 OGCMN：老年代最小容量 OGCMX：老年代最大容量 OGC：当前老年代大小 OC:当前老年代大小 YGC：年轻代gc次数 FGC：老年代GC次数</p><h3 id="如何排查Java程序死锁？"><a href="#如何排查Java程序死锁？" class="headerlink" title="如何排查Java程序死锁？"></a>如何排查Java程序死锁？</h3><p>使用 jstack<br>C:\Users\zhangchao&gt;jps 11856 12804 Jps 17016 Launcher C:\Users\zhangchao&gt;jstack 17016 &gt; D:&#x2F;jstack.txt<br>内容：<br>“DestroyJavaVM” #14 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x0000000002d77800 nid&#x3D;0x27d4 waiting on condition [0x0000000000000000]    java.lang.Thread.State: RUNNABLE “JPS event loop” #11 prio&#x3D;5 os_prio&#x3D;0 tid&#x3D;0x0000000018871000 nid&#x3D;0x3ed4 runnable [0x0000000018d7e000]    java.lang.Thread.State: RUNNABLE at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll0(Native Method) at sun.nio.ch.WindowsSelectorImpl$SubSelector.poll(WindowsSelectorImpl.java:296) at sun.nio.ch.WindowsSelectorImpl$SubSelector.access$400(WindowsSelectorImpl.java:278) at sun.nio.ch.WindowsSelectorImpl.doSelect(WindowsSelectorImpl.java:159) # 如果出现 DeadThread.run 说明死锁 # found deadlock，直接定位到死锁</p><h3 id="如何排查OOM问题？"><a href="#如何排查OOM问题？" class="headerlink" title="如何排查OOM问题？"></a>如何排查OOM问题？</h3><ul><li>让程序OOM的时候，自动dump出来</li></ul><p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;&#x2F;home&#x2F;work&#x2F;log&#x2F;dump</p><ul><li>手动通过 jmap 导出</li></ul><p>C:\Users\zhangchao&gt;jps 11856 12804 Jps 17016 Launcher C:\Users\zhangchao&gt;jmap -dump:format&#x3D;b,file&#x3D;D:&#x2F;heap.hprof 17016 Dumping heap to D:\heap.hprof … Heap dump file created<br>再用MAT工具分析，出分析报告<br>对象占比很大，一般都是溢出的位置</p><h3 id="如何GC调优？"><a href="#如何GC调优？" class="headerlink" title="如何GC调优？"></a>如何GC调优？</h3><p>打印GC日志：<br>-verbose:gc -XX:+PrintGCDetails –XX:+PrintGCTimeStamps –XX:+PrintGCDateStamps -Xloggc:$&#x2F;home&#x2F;logs&#x2F;gc.log<br>常用参数：<br>-Xms –Xmx ，初始堆和最大堆的大小 -XX:NewSize –XX:MaxNewSize ，新生代的大小、最大的新生代大小 -XX:NewRatio –XX:SurviorRatio ，新生代和老年代的比例，Sur和Eden的比例 -XX:MetaspaceSize –XX:MaxMetaspaceSize：元数据空间，最大元数据空间 -XX:+UseCompressedClassPointers，是否使用压缩的类型指针 -XX:CompressedClassSpaceSize ，压缩的类空间大小<br>GC分析工具：</p><ul><li>在线分析：<a href="https://gceasy.io/">https://gceasy.io/</a></li><li>本地分析：GCView</li></ul><p>关注点：</p><ul><li>吞吐量，响应时间。可能造成系统卡顿的原因</li><li>GC Cause，造成GC的原因</li></ul><p>JVM调优就是根据日志分析结果，不断试错的过程<br>频繁GC的原因：</p><ul><li>循环创建对象</li><li>静态变量或其它存活期很长的变量，是否太大，占用太多空间</li><li>没有打开“空间分配担保”，导致Full GC</li></ul><h2 id="SQL调优"><a href="#SQL调优" class="headerlink" title="SQL调优"></a>SQL调优</h2><p><a href="https://zhuanlan.zhihu.com/p/62941196">一条SQL语句执行得很慢的原因有哪些</a><br>碰到这种，无非分类讨论：</p><ul><li>其它的进程占用 CPU （使用 top 命令查看，确定系统资源） - 自己当前进程很慢 - 偶尔很慢 - 当前数据库正在同步数据 - 其它 sql 语句锁表了，正好是你查询的表 - 一直很慢，考虑优化 sql 语句</li></ul><ol><li>当我们要往数据库插入一条数据、或者要更新一条数据的时候，记录都会写入到 redo log 日记中去，等到空闲的时候，再把最新的数据同步到磁盘中去。日志同步导致 sql 查询慢</li><li>拿不到锁，刚好这条SQL涉及的表其它线程在用，我们拿不到锁</li><li>需要优化 sql</li></ol><h3 id="explain做语句分析"><a href="#explain做语句分析" class="headerlink" title="explain做语句分析"></a>explain做语句分析</h3><p><a href="https://blog.csdn.net/dennis211/article/details/78170079">mysql中explain的type的解释</a><br>通过explain做SQL调优，我们只关心三个字段：key：查找所用的索引rows：当前查找扫描的行数type：连接类型，常见的有六种连接类型all,index,range,ref,eq_ref,const，从左到右，效率是依次增强的，详细介绍：</p><ul><li>all，全表扫描，即使找到了，也要继续扫描着找，防止有多个值或者重复值</li><li>index也是全表扫描，只不过是按照索引的顺序；不一定比all强</li><li>range是范围扫描，除了显而易见的between，and以及’&gt;’,’&lt;’外，in和or也是索引范围扫描</li><li>ref：查找条件列使用了索引而且不为主键和unique</li><li>ref_eq：无重复，查询到一个就返回了</li><li>const，通常情况下，如果将一个主键放置到where后面作为条件查询，mysql优化器就能把这次查询优化转化为一个常量</li></ul><p>实例：<br>EXPLAIN SELECT <code>name</code>, <code>method</code> from website WHERE ip &#x3D; ‘127.0.0.1’;<br>分析结果：<br>key: null rows: 91749 type: ALL<br>给ip字段加上索引：<br>create index name001_index on website(ip)<br>再次分析：<br>key: name001_index，走了刚建的索引 rows: 25554,行数减少了 3 倍 type: ref，查询的时候用到了索引</p><h2 id="SQL题"><a href="#SQL题" class="headerlink" title="SQL题"></a>SQL题</h2><h3 id="查询各科成绩前三名"><a href="#查询各科成绩前三名" class="headerlink" title="查询各科成绩前三名"></a>查询各科成绩前三名</h3><p><a href="https://juejin.im/post/5d09e9046fb9a07f021a0499">https://juejin.im/post/5d09e9046fb9a07f021a0499</a></p><h2 id="如何处理高并发秒杀问题？"><a href="#如何处理高并发秒杀问题？" class="headerlink" title="如何处理高并发秒杀问题？"></a>如何处理高并发秒杀问题？</h2><p><a href="https://blog.csdn.net/liangkaiping0525/article/details/80836104">https://blog.csdn.net/liangkaiping0525/article/details/80836104</a><br>主要是两点：</p><ol><li>把请求拦截在系统的上游（不要落地到数据库中）</li><li>充分利用缓存（读多写少的请求）</li></ol><p>过滤掉一些重复请求：一个账户请求多次，一个IP反复请求的刷票；浏览器缓存，一个账户请求在浏览器中有记录的，你反复请求，JS不会让你发HTTP请求到服务器；即使你发上去了，服务器还有去重的操作<br>提前把余量读到缓存中，OK你要查询余量，直接查询缓存即可；不用读数据库做一个请求队列，来请求的线程排队，从缓冲中读入数据100余票，那么只放100个请求到数据库，其余的还在队列中，就让他直接返回（余票不足）</p>]]></content>
    
    
    <categories>
      
      <category>面试总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
      <tag>校招</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 面试总结</title>
    <link href="/2021/01/23/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/23/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/Java-%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>结合所有的资料，和自己总结过的，再次总结面试八股文<br>2021年1月23日</p><h1 id="Java知识点"><a href="#Java知识点" class="headerlink" title="Java知识点"></a>Java知识点</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>8个基本数据类型，1位&#x3D;1bit，1字节&#x3D;8位</p><ul><li>boolean 1bit</li><li>byte 1字节</li><li>char 2字节，和C++不一样，可以存放中文</li><li>short 2字节</li><li>int 4字节</li><li>float 4字节</li><li>long 8字节</li><li>double 8字节</li></ul><p><em>考点：隐式转换问题？</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.1</span>;  <span class="hljs-comment">//错误写法</span><br><span class="hljs-type">float</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.1f</span>; <span class="hljs-comment">//正确写法</span><br><span class="hljs-type">short</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>s1 += <span class="hljs-number">1</span>;        <span class="hljs-comment">//隐式转型，s1默认转化为int</span><br>s1++;           <span class="hljs-comment">//隐式转型，前两个都没问题</span><br>s1 = s1 + <span class="hljs-number">1</span>;    <span class="hljs-comment">//编译错误, s1 是 short，加完之后变成了 int</span><br></code></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p><em>考点：switch支持的数据类型？</em><br>从Java 7开始，可以在switch条件判断语句中使用String对象，但是不支持long、float、double</p><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>基本数据类型都有自己的包装类<br><em>考点：Integer 内部的缓存机制？</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br><span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">123</span>;<br>System.out.println(m == n); <span class="hljs-comment">// true 而当 m &gt; 128时，两个对象就不相等了</span><br><span class="hljs-comment">// 为何会出现这种情况？看看源码</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; 就等于 <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 源码</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>    &#125;<br><span class="hljs-comment">// low~high取值：-128~127，在这个范围内取数组 IntegerCache，内存地址都一样，自然相等</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br><span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br>System.out.println(m == n); <span class="hljs-comment">// false new 出来的堆内存分配，肯定不相等啊</span><br>a.equals(b) <span class="hljs-comment">// true, 因为重写了方法，比较的是 int 数值</span><br></code></pre></td></tr></table></figure><p><em>考点：&#x3D;&#x3D; 和 equal 的区别？</em></p><ol><li>&#x3D;&#x3D; 用于比较基本数据类型是否相等，以及对象的内存地址是否相等</li><li>equal是Object类中的方法，默认也是比较对象的内存（this &#x3D;&#x3D; obj），但是该方法是可以重写的！例如String就重写了这个方法，改为依次比较每个字符是否相等（首先先判断长度是否相等，因为长度都不等，字符肯定不同）</li></ol><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><em>考点：final的基本用法？</em></p><ul><li><p>常量，初始化后不能修改</p></li><li><p>对于引用类型，引用关系不可变，但是被引用的对象本身是可以变的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">4</span>;<br><span class="hljs-comment">// a 分配的地址是不能变的，但是地址里面的值可以变</span><br></code></pre></td></tr></table></figure></li><li><p>声明方法不能被子类重写</p></li><li><p>声明类不允许被继承</p></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><em>考点：String为什么不可变？哪里不可变？</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 源码上</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br><span class="hljs-comment">// final 数组，value[] 指向的内存是不能改变的。value[0]=&#x27;x&#x27;,这样是可以的，可以改变值，但是String并没有提供这种方法。所以不可变！</span><br></code></pre></td></tr></table></figure><p><em>考点：比较是否相等？String常量池？</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>); <span class="hljs-comment">// 出来了几个对象？</span><br><span class="hljs-comment">// 两个。 &quot;a&quot; 在常量池中，a 在堆内存中</span><br><span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>System.out.println(b==c); <span class="hljs-comment">// 相等，都引用的常量池</span><br><span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;d&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;d&quot;</span>);<br>System.out.println(d == e); <span class="hljs-comment">// 不相等，堆内存咋可能相等？</span><br>d.equal(e); <span class="hljs-comment">// 相等啊，重写了 equal 方法</span><br>d.intern(); <span class="hljs-comment">// 动态把字符串加入到常量池中</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">当一个字符串调用intern()方法时，如果String Pool中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回String Pool中字符串的引用；否则，就会在 String Pool中添加一个新的字符串，并返回这个新字符串的引用</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><em>考点：StringBuilder和StringBuffer，线程安全？</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 内部都是 char value[];都是内存可变的</span><br><span class="hljs-comment">// 增删改 StringBuffer 都加了synchronized 关键字，所以 StringBuffer 是线程安全的</span><br></code></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><em>考点：初始化顺序？</em></p><ul><li>初始化顺序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;static A&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;&#123;&#125; A&quot;</span>);<br>    &#125;<br><br>    A() &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造函数 A&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;static B&quot;</span>);<br>    &#125;<br><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;&#123;&#125; B&quot;</span>);<br>    &#125;<br><br>    B() &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造函数 B&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>(); <span class="hljs-comment">// 打印了啥？</span><br><span class="hljs-comment">/* 输出：</span><br><span class="hljs-comment">static A</span><br><span class="hljs-comment">static B</span><br><span class="hljs-comment">&#123;&#125; A</span><br><span class="hljs-comment">构造函数 A</span><br><span class="hljs-comment">&#123;&#125; B</span><br><span class="hljs-comment">构造函数 B</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p><em>考点：Object类有哪些方法？</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Map集合内部使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">// 默认调用 == 比较</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">// 重写这个方法才能clone，但是默认也是浅拷贝；重写方法后自己new对象，可实现深拷贝</span><br><span class="hljs-comment">// 需要申明实现Cloneable接口，虽然这个接口里面啥也没有</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">// 反射相关</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">// GC相关</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;&#125;<br><span class="hljs-comment">// 多线程相关</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br></code></pre></td></tr></table></figure><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p><em>考点：访问权限？</em></p><ul><li>public所有都可用，protected只在本包内可用（区别：包内包外）</li><li>private只在类中可用</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22879930/1653113699585-956c4a95-7533-4155-af6d-627857bb96e4.jpeg#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u4c584645&margin=%5Bobject%20Object%5D&name=%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90.jpg&originHeight=240&originWidth=324&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10021&status=done&style=none&taskId=ud8a64e37-7b2f-40c5-aafa-357082cf699&title=" alt="访问权限.jpg"></p><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><p><em>考点：基础</em></p><ul><li>一个类可以实现多个接口，但是不能继承多个(抽象)类</li><li>接口的字段只能是static和final类型的，而抽象类的字段没有这种限制</li><li>接口的成员只能是public的，而抽象类的成员可以有多种访问权限<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InterfaceExample</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// Java 8 之后接口都可以有默认的实现方法了</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;func2&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="this和super"><a href="#this和super" class="headerlink" title="this和super"></a>this和super</h3><p>访问本类，和访问父类……</p><h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p><em>考点：深浅拷贝？</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br><span class="hljs-type">A</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> a1; <span class="hljs-comment">// 指向的是同一块内存，a2 变了，a1也变了，浅拷贝</span><br><span class="hljs-comment">// 自己实现 clone() 方法，因为默认的啥也没干，然后 new 新的对象，赋值，完成深拷贝</span><br></code></pre></td></tr></table></figure><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p><em>考点：说一下反射，以及用法？</em><br>两个工具：</p><ul><li>Class类</li><li>java.lang.reflect 里面的工具类</li></ul><p>可以做什么？</p><ul><li>这个对象属于哪个类？A.class，a.getClass</li><li>通过字符串生成对象，Class.forName(“ClassExample”).newInstance();</li><li>获取类变量，方法，getFields，getMethods</li><li>甚至可以获取值，调用方法，Field::get，Method::invoke</li><li>RPC的实现</li></ul><p><em>通过反射获取私有变量的值？</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        <span class="hljs-type">Class</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> A.class;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> c.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>);<br>        f.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 注意是 true</span><br>        System.out.println(f.get(a));<br><span class="hljs-comment">// 打印出 123</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113716377-ff4b2f97-973d-4397-85fe-6d1c3a8dcc90.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=344&id=u28201fb1&margin=%5Bobject%20Object%5D&name=Java%E5%BC%82%E5%B8%B8.png&originHeight=458&originWidth=718&originalType=binary&ratio=1&rotation=0&showTitle=false&size=18102&status=done&style=none&taskId=ue789e32f-6f86-40cc-9436-a6dc429872b&title=&width=540" alt="Java异常.png"><br><em>考点：Error和Exception的区别？</em></p><ul><li>Error</li></ul><p>Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机（JVM）一般会选择终止线程。直接挂掉。<br>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如，当JVM不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError</p><ul><li>Exception</li></ul><p>Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常</p><ul><li>throw，自己写语句抛出</li><li>throws，函数声明的时候，有时候必须加上</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p><a href="https://cloud.tencent.com/developer/article/1033693">10道泛型面试题</a></p><h2 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113746757-e58f27a0-ad36-48e1-9184-8ab268658407.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=351&id=u3304566e&margin=%5Bobject%20Object%5D&name=%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB%E5%9B%BE.png&originHeight=426&originWidth=656&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103878&status=done&style=none&taskId=u1f19d581-46b3-4d60-85ff-bd39f293ef6&title=&width=541" alt="集合框架体系图.png"></p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p><em>考点：线程安全？内部原理？扩容机制？</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 内部实现，transient 声明的无法被序列化</span><br><span class="hljs-comment">// 内部是一个 Object 数组，默认大小为 10</span><br><span class="hljs-keyword">transient</span> Object[] elementData;<br><span class="hljs-comment">// 添加元素，先确认容量，不足则扩容，size 记录了当前元素个数，下标 +1</span><br><span class="hljs-comment">// 时间复杂度，O(1)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">// 删除元素，根据下标删除，找到删除的元素，删除后，把后面的元素依次往前挪（System.arraycopy）</span><br><span class="hljs-comment">// 返回删除后的元素，时间复杂度，O(n)</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br>        modCount++;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><span class="hljs-comment">// 扩容，原来的 1.5 倍，采用移位操作更快</span><br><span class="hljs-comment">// int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br></code></pre></td></tr></table></figure><ul><li>非线程安全</li><li>Vector线程安全，同样，增删改加了 synchronized 关键字</li></ul><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p><em>考点：内部实现？插入删除复杂度？</em></p><ul><li>和ArrayList一样，非线程安全</li><li>底层数据结构是双向链表</li><li>增加节点，尾插法，时间复杂度O(1)</li><li>查找节点，得从头节点开始遍历，时间复杂度O(n)</li></ul><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><em>考点：底层接口？线程安全？put和get源码？</em></p><ul><li><p>采用数组 + 链表组成的，用拉链法来解决冲突</p></li><li><p>当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</p></li><li><p>负载因子，默认是 0.75f。越大，说明越满</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先取一个哈希值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>    &#125;<br><span class="hljs-comment">// 添加元素</span><br>    <span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> evict)</span> &#123;<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;<br>        <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>            n = (tab = resize()).length;<br>        <span class="hljs-comment">// 取数组下标直接移位，(n - 1) &amp; hash，为什么？因为数组的长度是 2^n 次方</span><br>        <span class="hljs-comment">// 这个运算就等于 hash % n，位运算更快一些</span><br>        <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">else</span> &#123;<br>            Node&lt;K,V&gt; e; K k;<br>            <span class="hljs-comment">// 只有 hash 相等，且 equals 相等，才会被认为是相同的！</span><br>            <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>                ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                e = p;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                    <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                        p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>                        <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                            treeifyBin(tab, hash);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                        <span class="hljs-keyword">break</span>;<br>                    p = e;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>                <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>                <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                    e.value = value;<br>                afterNodeAccess(e);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        ++modCount;<br>        <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>            resize();<br>        afterNodeInsertion(evict);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>示意图</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113791417-070661c7-ae97-47e0-9a08-462f4e24b0c9.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=320&id=u38341345&margin=%5Bobject%20Object%5D&name=HashMap%E7%A4%BA%E6%84%8F.png&originHeight=545&originWidth=720&originalType=binary&ratio=1&rotation=0&showTitle=false&size=23933&status=done&style=none&taskId=uecf6285d-6f65-4cb0-b427-775b6bb25eb&title=&width=423" alt="HashMap示意.png"></p><p><em>考点：为什么重写了 hashCode 之后，equal 也要重写？</em></p><ul><li>内部集合都是这么判断的，只有都相同才认为是一个对象。不重写的话，Set集合里面放了两个相同值的对象</li></ul><p><em>考点：什么时候导致非线程安全？</em></p><ul><li>扩充，容量 * 2，所以元素重新 hash，重新放置</li><li>非线程安全，扩充的时候，拷贝链表的时候，多线程操作易死循环</li></ul><p><em>考点：Hashtable是否线程安全？</em><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113827539-e5e71be3-3990-44e4-9462-e08f799582a0.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=217&id=u428b461c&margin=%5Bobject%20Object%5D&name=HashMap%E6%AD%BB%E5%BE%AA%E7%8E%AF.png&originHeight=258&originWidth=670&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31569&status=done&style=none&taskId=u99523a7d-026d-43be-88d7-afcde6c85e2&title=&width=563" alt="HashMap死循环.png"></p><ul><li>Hashtable，不允许KV为null，synchronized关键字保证它是线程安全的，底层实现一样</li><li>HashSet，底层就是一个HashMap，用了一个final的对象作为所有map的value值，HashSet只用key值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// put 方法，里面套了一个 HashMap   </span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>    &#125;<br><span class="hljs-comment">// value 是不变的，只用到了 HashMap 的 key</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure></li></ul><h2 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h2><p>总结来自  <strong><em>&lt;&lt;Java虚拟机（第二版）&gt;&gt;</em></strong></p><h3 id="JVM分区"><a href="#JVM分区" class="headerlink" title="JVM分区"></a>JVM分区</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113862092-a21f30c4-7b12-4447-ad14-035ec39d4c20.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=428&id=u1c333bcc&margin=%5Bobject%20Object%5D&name=JVM%E5%88%86%E5%8C%BA.png&originHeight=532&originWidth=394&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92558&status=done&style=none&taskId=udbfb3993-6bb3-4d9e-b258-fa1f66ea135&title=&width=317" alt="JVM分区.png"><br><em>考点：JVM有哪些区域，分别是线程私有还是共享？</em></p><table><thead><tr><th>模块</th><th>功能</th><th>线程私有公有</th></tr></thead><tbody><tr><td>程序计数器</td><td>保存执行指令</td><td>私有</td></tr><tr><td>Java堆</td><td>对象new分配的空间</td><td>线程共享</td></tr><tr><td>Java栈</td><td>存放局部变量，参数等</td><td>私有</td></tr><tr><td>本地方法栈</td><td>执行的是native方法，变量参数等</td><td>私有</td></tr><tr><td>方法区</td><td>加载的类、常量池等</td><td>线程共享</td></tr></tbody></table><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><em>考点：拓展回答用</em><br>和TCP报文一样，对象分为对象头和对象内容，对象头包含两个部分：</p><ul><li><strong>Mark Word</strong>：存放HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</li></ul><p>和并发的知识点联系在一起……</p><ul><li>类型指针：指示它是哪个类的对象</li></ul><h3 id="GC的主要场所：堆"><a href="#GC的主要场所：堆" class="headerlink" title="GC的主要场所：堆"></a>GC的主要场所：堆</h3><p><em>考点：对象存活</em><br>对象已死吗？</p><ul><li>引用计数法</li></ul><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不被使用的</p><ul><li>缺点</li></ul><p>不能解决循环引用的问题</p><ul><li>可达性分析法（主流方法）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113912399-660782d2-105a-4cb4-b244-8fa383449ac6.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=251&id=u815e724e&margin=%5Bobject%20Object%5D&name=%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png&originHeight=310&originWidth=541&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14038&status=done&style=none&taskId=u64931d27-aea2-4c9b-b774-af8d49c4ade&title=&width=438" alt="可达性分析.png"><br>通过GC Roots作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收，可以作为GC Roots的对象：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul><h3 id="方法区也是可以被回收的"><a href="#方法区也是可以被回收的" class="headerlink" title="方法区也是可以被回收的"></a>方法区也是可以被回收的</h3><p><em>考点：方法区的回收</em><br>回收的主要内容：废弃常量和无用的类<br>无用的常量：假如一个字符串”a”没有任何对象引用它，那么这个常量将会被清理出常量池<br>无用的类：</p><ul><li>该类的所有实例都已经被回收</li><li>加载该类的ClassLoader已经被回收</li><li>该类的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>满足这些条件的类”可以”被回收，但不是一定被回收。在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</p><h3 id="finalize-之对象的重生"><a href="#finalize-之对象的重生" class="headerlink" title="finalize()之对象的重生"></a>finalize()之对象的重生</h3><p><em>考点：final、finally、finalize区别？</em><br>如果对象脱离了”GC Roots”，不一定会非死不可，对于这种对象：</p><ul><li>如果它的finalize()方法已经执行过了或者没有覆盖这个方法，就直接被GC</li><li>否则会被放在F-Queue中，Finalizer线程会依次执行每个对象的finalize()方法，某个对象如果在finalize()中有死循环，会导致回收系统崩溃</li><li>如果一个对象在finalize()方法中建立了新的引用，比如把this赋给了活着的对象，那么它就存活了</li></ul><p>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，就必死无疑；同时，并不鼓励大家使用这种方法来拯救对象</p><h3 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h3><p><em>考点：四种引用</em></p><ul><li>强引用：被强引用关联的对象不会被回收；new出来的对象</li><li>软引用：内存不够才会回收它；使用 SoftReference 类来创建软引用</li><li>弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前；使用 WeakReference 类来实现弱引用</li><li>虚引用：无法通过虚引用取得一个对象，唯一作用是它被回收时会收到一个系统通知；使用 PhantomReference 来实现虚引用</li></ul><h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p><em>考点：GC算法</em></p><ul><li>标记清除</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113942503-5623a5fd-8302-438b-951d-fa38c923112f.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=180&id=u78bc141a&margin=%5Bobject%20Object%5D&name=%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png&originHeight=193&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42149&status=done&style=none&taskId=u9a2c5a61-decc-4dae-8dde-187deda45da&title=&width=518" alt="标记清除.png"><br>标记要回收的对象，然后清除</p><p>问题：<br>标记和清除的效率都很低；产生内存碎片</p><ul><li>标记-整理</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113973174-2c9f13c3-23f9-4a00-bb18-12019184d82c.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=195&id=ud09ec603&margin=%5Bobject%20Object%5D&name=%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86.png&originHeight=204&originWidth=545&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52753&status=done&style=none&taskId=u82ab9132-4fd6-4c11-a637-8d4253a0db0&title=&width=520" alt="标记整理.png"><br>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p><ul><li>复制算法</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653113998961-cc1af0ad-e28f-46d6-be60-d6354ebb4079.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=192&id=u1991ef6d&margin=%5Bobject%20Object%5D&name=%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png&originHeight=206&originWidth=572&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82523&status=done&style=none&taskId=uce86a947-d793-4202-b0c2-d7ad2fc224a&title=&width=533" alt="复制算法.png"><br>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理</p><p>当然浪费一半的内存效率太低了，HotSpot虚拟机采用较大的Eden空间和两块较小的Survivor空间，Eden:Survivor &#x3D; 8:1。GC时把Eden和Survivor存活的对象复制到另一块Survivor上，再清除其它的</p><p>如果一块Survivor不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象</p><h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p><em>考点：分代回收算法</em><br>堆分为新生代和老年代，一般情况下：</p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记-清除或者标记-整理算法</li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><em>考点：垃圾收集器</em><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114032580-70755351-90dc-43aa-8900-b39a533709f4.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=334&id=uc90cd887&margin=%5Bobject%20Object%5D&name=%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png&originHeight=387&originWidth=557&originalType=binary&ratio=1&rotation=0&showTitle=false&size=102482&status=done&style=none&taskId=u39681df5-9a1d-49b2-84ff-d2cb1134def&title=&width=480" alt="垃圾收集器.png"><br>以上是HotSpot虚拟机中的7个垃圾收集器，连线表示垃圾收集器可以配合使用；主要分为：</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程进行收集，而多线程使用多个线程</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行<table><thead><tr><th>收集器</th><th>串行&#x2F;并行</th><th>单线程&#x2F;多线程</th></tr></thead><tbody><tr><td>Serial</td><td>串行</td><td>单线程</td></tr><tr><td>ParNew</td><td>串行</td><td>多线程</td></tr><tr><td>Parallel Scavenge</td><td>串行</td><td>多线程</td></tr><tr><td>Serial Old</td><td>串行</td><td>单线程</td></tr><tr><td>Parallel Old</td><td>串行</td><td>多线程</td></tr><tr><td>CMS</td><td>并行</td><td>多线程</td></tr><tr><td>G1</td><td>并行</td><td>多线程</td></tr></tbody></table></li></ul><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p><em>考点：Minor GC和Full GC？</em></p><ul><li>Minor GC：发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快</li><li>Full GC：发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多</li></ul><h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p><em>考点：一个对象的分配策略？</em></p><ul><li>对象优先在 Eden 分配，当 Eden 区空间不够时，发起 Minor GC</li><li>大对象直接进入老年代，避免在 Eden 区和 Survivor 区之间的大量内存复制</li><li>长期存活的对象进入老年代，为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中；-XX:MaxTenuringThreshold 用来定义年龄的阈值</li><li>动态对象年龄判定，虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄</li></ul><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p><em>考点：空间分配担保？</em><br>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间<strong>是否大于历次晋升到老年代对象的平均大小</strong>，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC</p><h4 id="GC触发条件"><a href="#GC触发条件" class="headerlink" title="GC触发条件"></a>GC触发条件</h4><p><em>考点：GC条件</em><br>Minor GC</p><ul><li>其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC</li></ul><p>Full GC</p><ul><li>调用 System.gc()，只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行</li><li>老年代空间不足</li><li>空间分配担保失败</li></ul><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><em>考点：类加载，类的生命周期？</em></p><ul><li>类的生命周期</li></ul><p>加载，验证，准备，解析，初始化，使用，卸载。7个阶段<br>前5个阶段，类加载：加载，验证，准备，解析，初始化<br>验证，准备，解析合称为链接</p><ul><li>类的唯一性</li></ul><p>只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><em>考点：类加载器和双亲委派模型？</em><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114076721-36d58fdf-ef49-4525-b523-fc2219c8cb38.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=163&id=u5cfeabe9&margin=%5Bobject%20Object%5D&name=%E7%B1%BB%E5%8A%A0%E8%BD%BD.png&originHeight=186&originWidth=611&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88103&status=done&style=none&taskId=u1b1471e9-4020-4343-affe-3d346279637&title=&width=537" alt="类加载.png"></p><ul><li>启动类加载器，Bootstrap ClassLoader，这个类加载器使用C++语言实现，是虚拟机本身的一部分</li><li>扩展类加载器（Extension ClassLoader）由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的类库</li><li>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher $AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</li></ul><p>双亲委派模型：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114112463-2c43c070-8889-4d2f-9da3-c4ea52646bb2.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=337&id=u17c16c64&margin=%5Bobject%20Object%5D&name=%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png&originHeight=411&originWidth=367&originalType=binary&ratio=1&rotation=0&showTitle=false&size=61258&status=done&style=none&taskId=u11e25f0e-1c9d-4816-ab48-0cf5d75cd15&title=&width=301" alt="双亲委派模型.png"><br>启动类加载器-&gt;扩展类加载器-&gt;应用程序类加载器-&gt;自定义类加载器，这种类加载器之间的层次关系，称为双亲委派模型；</p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载</p><ul><li>作用</li></ul><p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类</p><h4 id="Java客户端程序，服务器程序区别？"><a href="#Java客户端程序，服务器程序区别？" class="headerlink" title="Java客户端程序，服务器程序区别？"></a>Java客户端程序，服务器程序区别？</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114140327-4e5a8533-ee9b-40c9-ac30-177d45fed9de.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=281&id=uce695019&margin=%5Bobject%20Object%5D&name=Java%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C.png&originHeight=314&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=38242&status=done&style=none&taskId=u25dd4329-d63b-4cf1-9727-afe7f2e063e&title=&width=448" alt="Java代码执行.png"><br>Java既可以解释执行（解释执行的效率慢一些），也可以编译执行；Java有多个即时编译器，C1、C2和Graal。<br>C1：面对启动性能较高的GUI客户端程序<br>C2：面向对峰值性能有要求的服务器程序<br>（也是JDK server和JDK client的区别）<br>Java7开始，HotSpot默认采用分层编译的方式：热点方法首先会被C1编译，然后再被C2编译<br>HotSpot 会根据 CPU 的数量设置编译线程的数目，并且按 1:2 的比例配置给 C1 及 C2 编译器，在计算资源充足的情况下，字节码的解释执行和即时编译可同时进行。编译完成后的机器码会在下次调用该方法时启用，以替换原本的解释执行<br>HotSpot装载了多个不同的即时编译器，以便在编译时间和生成代码的执行效率之间做取舍</p><h2 id="Java并发"><a href="#Java并发" class="headerlink" title="Java并发"></a>Java并发</h2><p>总结来自  <strong><em>&lt;&lt;Java并发编程的艺术&gt;&gt;</em></strong></p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><em>考点：关键字作用？</em><br>讲到这个关键字，可以涉及两个知识点：</p><ul><li>Java内存模型</li><li>重排序：插入内存屏障，防止某些片段的重排，影响语义</li></ul><p>主内存+线程拷贝内存，为了保证运行的效率，每个线程会从主内存中拷贝副本运行，导致了不同线程看到的变量不一致<br>被关键字修饰的变量，一旦修改，会对所有的线程可见；原理：加了volatile变量后，当这个变量被修改后，汇编代码会多出一行lock指令，这个指令有两个作用：</p><ul><li>将当前处理器的缓存写回到系统内存中</li><li>写回内存的操作使得其它地方的这个缓存副本无效</li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><em>考点：synchronized的作用？底层实现？锁升级？</em><br>底层指令是通过成双的monitorenter和monitorexit来实现的<br>任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁<br>获取锁失败的对象进入同步队列（SynchronizedQueue），状态变为阻塞BLOCKED状态<br>加锁的本质也是一种线程之间的通信<br>锁升级：<br>锁一共分为4个等级，无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不可以降级，区别：</p><ul><li>无锁，就不说了，不加锁</li><li>偏向锁：为了防止一个线程频繁的进入一个同步块，浪费锁；将对象头（JVM中讲到）中的锁信息标明为这个线程的ID，同时有个bool变量0&#x2F;1设置为当前为偏向锁</li><li>轻量级锁：将对象的Mark Word拷贝到自己线程的私有空间，就加锁了，若失败，则说明存在竞争；解锁，再把Mark Word替换回去。两个线程只要不同时进入同步块，那就是轻量级锁</li><li>重量级锁，当线程获取锁时，都会被阻塞，当持有锁的线程释放锁后会唤醒阻塞的线程，被唤醒的线程就会进行下一轮的夺锁之争；一旦两个线程尝试同时进入，升级为重量级锁</li></ul><h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p><em>考点：Java内存模型？</em></p><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>Java并发采用的是共享内存模型<br>实例域、静态域和数组元素存储在堆内存中，是线程共享的。局部变量和函数参数存在栈中，不是线程共享，因此不存在内存可见性问题<br>除了主内存以外，每个线程有自己的本地内存，存放主内存中共享变量的副本。副本和实体的同步由JMM（Java内存模型）控制；如果A和B需要通信，A必须把更新过的共享变量刷新到内存中，B要去读已经更新过的共享变量</p><h4 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h4><p>在不改变程序执行结果的前提下，尽可能的提高并行度；我们所执行的指令都是经过重排序的结果：编译器重排-&gt;指令重排-&gt;内存重排<br>对于JMM而言，它会禁止特定类型的重排，为程序员提供一致的内存可见性保证</p><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>前一个操作执行的结果必须要对后一个操作可见，不意味着前一个操作必须在后一个操作之前执行</p><p>正确加锁的多线程程序，重排序是遵守happens-before原则的，保证程序不会出错</p><p>包括volatile关键字和锁，本质就是在重排序的时候加入了<code>内存屏障</code>，防止了某些重排序对程序正确性的影响，保证了多线程运行的正确性</p><h3 id="ReentrantLock的实现"><a href="#ReentrantLock的实现" class="headerlink" title="ReentrantLock的实现"></a>ReentrantLock的实现</h3><p>ReentrantLock的实现是基于Java同步器框架AbstractQueuedSynchronizer，简称AQS实现的；而AQS使用了一个整型的volatile变量state来维护同步状态，这个变量是实现锁的关键：</p><ul><li>加锁先读state</li><li>释放锁后更新state</li><li>state的更新都是基于CAS操作</li></ul><p>ReentrantLock中的公平锁和非公平锁：</p><ul><li>相对于获取锁的时机来定义的，公平锁的获取按照先来先到的顺序，按照队列中的顺序来获取</li><li>非公平锁允许”插队”，可以不按顺序来</li><li>参数true是公平，false是不公平</li></ul><p>ReentrantLock是重入锁，顾名思义，可以重复加锁；还是维护state变量，每加锁一次，加1；释放锁一次，减1；当state为0时代表无锁</p><h4 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h4><p>使用场景，ReentrantLock：</p><ul><li>tryLock()接口，可以指定尝试的时间，提供了一种定时结束等待的方式；如果线程在指定的时间没有获取锁，就返回false并停止等待</li><li>可中断：lockInterruptibly，等待获取锁的过程中，线程可被中断；不像syn关键字，等不到锁就一直等待（饥饿）</li><li>条件队列：线程在获取不到锁后，进入等待状态（Object.wait()方法或者Condition.await()方法），进入等待状态的线程会挂起并释放锁，进入条件队列；synchronized只有一个条件队列，而ReentrantLock有多个（参考阻塞队列中的notFull和notEmpty两个条件队列）</li></ul><p>何为条件？线程获取锁后，要满足一定的条件才能执行，比如生产者生产，队列满了，只能等待。ReentrantLock可以维护多个条件队列，结合阻塞队列讲</p><ul><li>公平和非公平：等待syn锁的线程进入队列后，每次随机的从队列中取出一个获取锁，这样导致有些线程饥饿。对于ReentrantLock，可以实现公平锁，先来先到</li></ul><p>最后，syn关键字是可重入的！可重入的！可重入的！<br>总之：在线程并发比较少的情况下，用syn关键字是很好的选择；在高并发的情况下，需要灵活的使用锁，这个时候用ReentrantLock比较好</p><h3 id="读写锁ReentrantReadWriteLock"><a href="#读写锁ReentrantReadWriteLock" class="headerlink" title="读写锁ReentrantReadWriteLock"></a>读写锁ReentrantReadWriteLock</h3><p>读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> rwl.readLock();<br><span class="hljs-keyword">static</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> rwl.writeLock();<br></code></pre></td></tr></table></figure><h4 id="读写锁是怎么维护重入次数的？"><a href="#读写锁是怎么维护重入次数的？" class="headerlink" title="读写锁是怎么维护重入次数的？"></a>读写锁是怎么维护重入次数的？</h4><p>如图所示，将一个32位的整型变量分成两个16位的区域，分别用来维护读、写的加锁次数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114171600-a5f35965-7dac-42df-ae38-9f5764f02fb4.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=252&id=u833d636e&margin=%5Bobject%20Object%5D&name=%E8%AF%BB%E5%86%99%E9%94%81.png&originHeight=307&originWidth=690&originalType=binary&ratio=1&rotation=0&showTitle=false&size=70157&status=done&style=none&taskId=u2c22a96a-b18b-4c8b-beea-fd13e9b53bc&title=&width=567" alt="读写锁.png"></p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值；编译器不能对CAS与CAS前面和后面的任意内存操作重排序<br>CAS（compareAndSet）的实现，再往下就是sun.misc.Unsafe类的compareAndSwapInt方法，是一个Native方法</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><ul><li>创建，new</li><li>就绪，调用了start()方法，等CPU调度</li><li>运行，CPU执行了run方法</li><li>阻塞，停止执行，将资源交给其它线程</li><li>终止，线程销毁</li></ul><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><p>setPriority(int)方法来修改优先级，优先级高的线程分配时间片的数量要多于优先级低的线程</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作；Thread.setDaemon(true)将线程设置为Daemon线程</p><h4 id="构造线程的方法"><a href="#构造线程的方法" class="headerlink" title="构造线程的方法"></a>构造线程的方法</h4><ul><li>继承 Thread 类</li><li>实现 Runnable 接口</li><li>实现 Callable 接口；配合FutureTask使用，有返回值的线程</li></ul><h4 id="安全的停止线程"><a href="#安全的停止线程" class="headerlink" title="安全的停止线程"></a>安全的停止线程</h4><ul><li>interrupt()函数中断线程，中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务</li><li>利用一个boolean变量来控制是否需要停止任务并终止该线程</li></ul><p>过期的方法，不安全：</p><ul><li>suspend()</li><li>resume()</li><li>stop()</li></ul><h4 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h4><ul><li>volatile和synchronized关键字</li><li>管道流输入输出</li><li>等待、通知机制</li><li>Thread.join()</li><li>ThreadLocal</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>从源码分析，每个线程都有一个Map互不干扰，key是当前的this指针即ThreadLocal对象本身，value是线程存的值</p><ul><li><p>set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br><span class="hljs-comment">//首先获取当前的线程</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">//根据线程获取Map，没有则创建一个，创建后设置值</span><br><span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br><span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br><span class="hljs-comment">//key值为this对象即是当前的ThreadLocal对象</span><br>map.set(<span class="hljs-built_in">this</span>, value);<br><span class="hljs-keyword">else</span><br>createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>get</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br><span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">//getEntry方法也是通过threadLocalHashCode来取值的</span><br>ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br><span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>只关注1.8版本，不要在意和之前的有什么区别</p><ul><li>put</li></ul><p>重点，1.8丢弃了segment分段锁的概念。之前和HashMap操作一样，当找到要放入的位置时：</p><ol><li>先用casTabAt函数尝试着放，若放入，则OK。否则说明存在并发操作</li><li>再用synchronized关键字对当前链表头节点加锁，再进行安全的put</li></ol><p>稍后看看源码</p><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>一个基于单链表的队列，它维护了两个重要的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//头节点和为节点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; head;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node&lt;E&gt; tail;<br></code></pre></td></tr></table></figure><ul><li>入队列使用CAS操作重新定位尾节点，不成功则循环操作</li><li>出队列使用CAS操作定义头节点</li></ul><p>整个队列没有加锁，全靠CAS操作，使得效率较高</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul><li>插入阻塞：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满</li><li>移除阻塞：意思是在队列为空时，获取元素的线程会等待队列变为非空</li></ul><p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器<br>JDK7有7个阻塞队列：</p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li></ul><p>阻塞队列的实现原理：<br>使用通知模式实现。所谓通知模式，就是当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用</p><h4 id="重点分析两个"><a href="#重点分析两个" class="headerlink" title="重点分析两个"></a>重点分析两个</h4><ul><li><p>ArrayBlockingQueue</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加数据</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        checkNotNull(e);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        <span class="hljs-comment">// 如果当前线程未被中断则获得锁,如果当前线程被中断则出现异常</span><br>        <span class="hljs-comment">// 本身这个等待可以被中断的</span><br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == items.length)<br>                notFull.await();<br>            enqueue(e);<br>            <span class="hljs-comment">// notEmpty.signal();</span><br>            <span class="hljs-comment">// 入队列后唤醒消费者</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>&#125;<br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>                notEmpty.await();<br>            <span class="hljs-keyword">return</span> dequeue();<br>            <span class="hljs-comment">// notFull.signal();</span><br>            <span class="hljs-comment">// 出队列后唤醒生产者</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>LinkedBlockingQueue</p></li></ul><p>大致是一样的，有一些小区别：</p><ol><li>基于链表，创建时不需要指定大小</li><li>ArrayBlockingQueue使用的是一个lock，而LinkedBlockingQueue采用的是putLock和takeLock；意味这两个线程可以同时操作头尾</li></ol><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>原子类实现的方式大同小异，这里就分析一下AtomicInteger，提供的方法（有点过时了）：</p><ul><li>int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果</li><li>boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值</li><li>int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值</li><li>void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值</li><li>int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值</li></ul><h4 id="循环CAS"><a href="#循环CAS" class="headerlink" title="循环CAS"></a>循环CAS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">for</span> (;;) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> get();<br><span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (compareAndSet(current, next))<br><span class="hljs-keyword">return</span> current;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>循环CAS的操作是可以保证原子性的，JDK1.7之前for循环 + compareAndSet，直到成功为止！compareAndSet底层也是Unsafe类<br>JDK1.8直接调用的Unsafe类的相关方法</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="创建方式1"><a href="#创建方式1" class="headerlink" title="创建方式1"></a>创建方式1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">通过 Executors.newXXX 创建，其底层是调用 new ThreadPoolExecutor</span><br><span class="hljs-comment">来实现的，只不过传参不同</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 0~Integer.MAX_VALUE，任务来了无线创建线程，线程执行完后（闲置） 1 分钟销毁</span><br><span class="hljs-comment">// 阻塞队列：SynchronousQueue，长度为 0</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool1</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><span class="hljs-comment">// 核心线程=最大线程=参数，执行完后立即销毁</span><br><span class="hljs-comment">// 阻塞队列：LinkedBlockingQueue，长度为 MAX_VALUE</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool2</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">缺点都很明显，可以无限的 put 线程，也没有拒绝策略，导致 OOM 问题!</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="创建方式2"><a href="#创建方式2" class="headerlink" title="创建方式2"></a>创建方式2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">poo3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-number">5</span>,          <span class="hljs-comment">// 核心线程池数量</span><br>                <span class="hljs-number">10</span>,    <span class="hljs-comment">// 最大线程池数量</span><br>                <span class="hljs-number">60</span>,       <span class="hljs-comment">// 闲置后销毁时间</span><br>                TimeUnit.SECONDS,       <span class="hljs-comment">// 时间单位</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">10</span>)<br>                <span class="hljs-comment">// 阻塞队列</span><br>        );<br></code></pre></td></tr></table></figure><p>线程池的参数：</p><ul><li>corePoolSize，核心线程数：超过此值将任务加入阻塞队列</li><li>maximumPoolSize，最大线程数：阻塞队列已满？线程数量扩至此值，需要获取全局锁</li><li>keepAliveTime，unit：线程闲置后的销毁时间以及时间单位</li><li>BlockingQueue：指定阻塞队列</li><li>ThreadFactory：线程工程，它是个接口，里面就一个方法<code>newThread</code>，默认使用的<code>DefaultThreadFactory</code>，就是创建线程的时候加一些修饰，比如设置为后台线程，改下名字之类</li></ul><h4 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h4><p>JDK1.8，线程池的<code>execute</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 写的比较巧妙，函数和if判断写在一起</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>       <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><span class="hljs-comment">// addWorker第二次参数，true是比较corePoolSize，false是比较maximumPoolSize</span><br>       <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>           <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>               <span class="hljs-keyword">return</span>;<br>           c = ctl.get();<br>       &#125;<br>       <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>           <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>               reject(command);<br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>               addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>       &#125;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>           reject(command);<br>   &#125;<br></code></pre></td></tr></table></figure><ol><li>如果当前运行的Worker线程小于corePoolSize，直接增加Worker，调用addWorker方法。</li><li>addWorker失败后，如果线程池处于运行状态，就把任务放到阻塞队列；然后立马再次检查一遍，如果线程池不处于运行状态，就从队列中移除任务，并且调用拒绝策略</li><li>这里JDK1.8和1.7的写法有些变动，如果线程池还是运行的，并且线程数为0（担心任务提交到队列中了，但是线程都关闭），再次调用addWorker方法</li><li>入队列失败，在不超过maximumPoolSize大小的情况下再次addWorker；如果失败，任务将被拒绝，并且调用拒绝策略来处理</li></ol><h4 id="何为Worker？"><a href="#何为Worker？" class="headerlink" title="何为Worker？"></a>何为Worker？</h4><p>对当前的工作线程进行一个封装，成了一个Worker线程；addWorker方法：这个方法允许失败，首先先用循环CAS的方法，把当前的线程数poolSize+1，然后新建一个Worker，加锁mainLock，把新建的Worker放到worker队列里面</p><h4 id="四种拒绝策略："><a href="#四种拒绝策略：" class="headerlink" title="四种拒绝策略："></a>四种拒绝策略：</h4><p>默认直接抛出RejectedExecutionException异常<br>还有另外三种：</p><ul><li>只要线程池没有关闭，那么由提交任务的线程来自己执行这个任务；</li><li>不做任何处理，直接丢弃</li><li>把队列头的任务丢弃，把新任务加到队列中</li></ul><h4 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h4><ul><li><p>无返回值的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">threadsPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// TODO Auto-generated method stub</span><br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>有返回值的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// harReturnValuetask 被包装为 FutureTask</span><br>Future&lt;Object&gt; future = executor.submit(harReturnValuetask);<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 如果返回值未到，获取会阻塞！</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> future.get();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// 处理中断异常</span><br>&#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br><span class="hljs-comment">// 处理无法执行任务异常</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">// 关闭线程池</span><br>executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><p>shutdown或shutdownNow方法</p><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>阻塞队列已经实现了生产者，消费者模型。所以直接复用阻塞队列的代码是标准答案<br>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductConsume</span> &#123;<br>    <span class="hljs-comment">// 1 把锁，1个队列，2个条件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">full</span> <span class="hljs-operator">=</span> reentrantLock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">empty</span> <span class="hljs-operator">=</span> reentrantLock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> reentrantLock;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lockInterruptibly();<br>                <span class="hljs-keyword">while</span> (list.size() == MAX_SIZE) &#123;<br>                    full.await();<br>                &#125;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;data&quot;</span>;<br>                list.add(data);<br>                empty.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> reentrantLock;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lockInterruptibly();<br>                <span class="hljs-keyword">while</span> (list.size() == <span class="hljs-number">0</span>) &#123;<br>                    empty.await();<br>                &#125;<br>                list.remove(<span class="hljs-number">0</span>);<br>                full.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><p><a href="https://www.javadoop.com/post/java-nio">NIO三大组件</a><br><a href="https://www.javadoop.com/post/nio-and-aio#%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%20IO">NIO详解</a><br>了解就行，谈谈自己的理解<br>CPU在执行任务的时候，可以分为两种任务：1. 几乎不耗时的，例如执行代码逻辑；2. 消耗时间的，与外部系统做IO，数据库连接、网络连接等。当两种任务在一起时，拉低了CPU的执行相率!为什么，CPU在做数据库连接的时候，CPU的时间消耗在等待上!CPU空闲了，没有得到充分的利用</p><ul><li>同步，发出请求，等待完成，然后返回结果</li><li>异步，发出请求，不等待结果（如果你一定要立马得到结果才能进行下一步的操作，这是肯定要阻塞的，future.get），继续往后执行，传入回调函数。第三方完成后将结果写入回调函数，回调你，告知已完成</li></ul><p>两种IO：<br>阻塞IO即是同步IO，非阻塞IO即为异步IO</p><h3 id="网络IO的发展"><a href="#网络IO的发展" class="headerlink" title="网络IO的发展"></a>网络IO的发展</h3><ul><li>阻塞IO</li></ul><p>早期的网络服务，来一个请求就创建一个线程，处理完请求后返回。缺点很多：</p><ol><li>线程得不到管理，线程的创建和销毁开销很大，极其浪费CPU资源</li><li>无限制请求岂不是崩盘？</li></ol><p>改进：利用线程池来管理线程的创建，使得线程复用。但是治标不治本，一旦线程过多，频繁的上下文切换也顶不住</p><ul><li>异步IO</li></ul><p>基于事件驱动的模型，一个线程用到轮训请求，足矣，因为不等待，收到一个请求发出事件即可。<br>由其它的处理线程，处理完后告知结果（只发出IO指令，不处理IO结果）</p><h3 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select,poll,epoll"></a>select,poll,epoll</h3><p><a href="https://www.cnblogs.com/lxmhhy/p/6214113.html">博客</a></p><h2 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h2><p><a href="https://www.jianshu.com/p/40d0a6ad21d2">SpringIOC和AOP原理</a><br><a href="https://www.jianshu.com/p/e4ca039a2272">深入理解 Spring 之源码剖析IOC</a><br>了解即可</p><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>IOC控制反转和DI依赖注入是一个意思，都是把创建对象实例的权利交给容器？以往我们写后端程序，Controller层调用Service层，Service调用Dao层，这样直接new出来，层与层之间存在很强的依赖关系，现在是把new的过程交给Spring容器</p><p>IOC注入过程：</p><ul><li>XMLReader去解析我们的xml配置文件，把XML解析成BeanDefinitions，最后把beanDefinition注册到BeanFactory中</li><li>注册，以beanName为key，beanDefinition为value，放到ConcurrentHashMap中</li></ul><p>如何创建Bean实例并构建Bean的依赖关系网？</p><ul><li>beanFactory.preInstantiateSingletons()，该方法首先循环所有的BeanNames，并且调用getBean方法；递归完成注入</li><li>getBean的关键代码createBeanInstance和populateBean；一个是创建类的实例，一个是给类注入依赖</li><li>注入的过程会判断是不是基本数据类型（int之类），如果不是，通过获取构造器，反射创建实例</li></ul><p>BeanDefinition核心数据结构：<br>每个bean都有自己的信息，各个属性，类名，类型，是否单例；除了此以外，Spring通过定义 BeanDefinition 来管理基于Spring的应用中的各种对象以及他们直接的相互依赖关系；它是容器实现IOC的核心数据结构</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>代理模式；我们在写业务代码时，有很多非业务功能每个地方都要用到，比如写日志、事务管理、权限什么的，我们不可能在每个地方都写代码兼顾这些东西；Spring就通过AOP来帮我们做这些东西，用到了代理模式，通过一个注解来帮我们做事务管理<br>AOP源码解析：<a href="https://www.cnblogs.com/downey/p/4888451.html">源码解析</a></p><ul><li>声明式Spring AOP代理工厂对象ProxyFactoryBean，ProxyFactoryBean是Spring中一个非常灵活的创建AOP应用的底层方法，封装了AOP的主要功能</li><li>ProxyFactoryBean生成AOP Proxy代理对象</li><li>DefaultAopProxyFactory创建AOP Proxy代理对象，代理的过程中：如果配置的目标类是接口，则使用JDK的动态代理机制来生成AOP代理，如果使用的不是接口，则使用CGLIB方式来生成AOP的动态代理</li><li>DefaultAopProxyFactory的手下有CglibProxyFactory和JdkDynamicAopProxy</li></ul><p>JDK代理和Cglib代理区别：</p><ul><li>JDK动态代理：只能代理实现了接口的类，通过实现InvocationHandler这个接口的invoke方法来实现，并在方法前后加上自己想添加的功能；通过字节码框架动态的生成字节码，获取class信息后再通过反射生成实例</li><li>Cglib代理：直接代理委托类，它的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，所以不能对final修饰的类进行代理</li></ul><h3 id="Spring-MVC流程"><a href="#Spring-MVC流程" class="headerlink" title="Spring MVC流程"></a>Spring MVC流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114215155-caf50e06-8c37-453a-888a-0bb77c47dd17.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=359&id=u7d084200&margin=%5Bobject%20Object%5D&name=springmvc%E6%B5%81%E7%A8%8B.png&originHeight=442&originWidth=689&originalType=binary&ratio=1&rotation=0&showTitle=false&size=264041&status=done&style=none&taskId=u3210f93e-39eb-475d-abd4-01270693107&title=&width=559" alt="springmvc流程.png"></p><ol><li>用户发起一个request请求，如果有多个DispatcherServlet，则通过Servletmapping去指定执行的DispatcherServlet</li><li>DispatcherServlet把根据URL请求，去HandlerMapping中查找注册了的URL映射，并返回相应的Handler（一个Controller，多个拦截器），给DispatcherServlet</li><li>DispatcherServlet传递Handler给HandlerAdapter去执行，返回一个ModelAndView</li><li>DispatcherServlet把ModelAndView传递给视图解析器去解析，返回一个视图view</li><li>组装上Model数据后变成Response请求返回给客户端</li></ol><h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>在Web项目启动的时候，URL信息都被保存在HandlerMapping中；遍历这个Map，找到相应的Handler，也就是哪个类的哪个方法，找到方法执行</p><h3 id="Spring中用到的设计模式"><a href="#Spring中用到的设计模式" class="headerlink" title="Spring中用到的设计模式"></a>Spring中用到的设计模式</h3><p><a href="https://www.cnblogs.com/dream-to-pku/p/9540387.html">Spring中的设计模式</a></p><ul><li>BeanFactory的getBean方法去获取Bean就是一个简单工厂</li><li>定义一个用于创建对象的接口，让子类决定去实例化哪一个类。Factory Method使一个类的实例化延迟到子类，Spring中的FactoryBean就是典型的工厂方法模式</li><li>保证一个类仅有一个实例；对象作用域singleton</li><li>代理模式；AOP</li><li>观察者，Spring中Observer模式常用的地方是listener的实现。如ApplicationListener</li></ul><h3 id="Spring-Bean-的生命周期和作用域"><a href="#Spring-Bean-的生命周期和作用域" class="headerlink" title="Spring Bean 的生命周期和作用域"></a>Spring Bean 的生命周期和作用域</h3><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Spring Bean 生命周期比较复杂，可以分为创建和销毁两个过程<br>创建Bean：</p><ul><li>实例化 Bean 对象</li><li>设置 Bean 属性</li><li>如果我们通过各种 Aware 接口声明了依赖关系，则会注入 Bean 对容器基础设施层面的依赖</li><li>调用 BeanPostProcessor 的前置初始化方法 postProcessBeforeInitialization</li><li>如果实现了 InitializingBean 接口，则会调用 afterPropertiesSet 方法</li><li>调用 Bean 自身定义的 init 方法</li><li>调用 BeanPostProcessor 的后置初始化方法 postProcessAfterInitialization</li></ul><p>销毁Bean：<br>Spring Bean 的销毁过程会依次调用 DisposableBean 的 destroy 方法和 Bean 自身定制的 destroy 方法</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul><li>Singleton，这是 Spring 的默认作用域，也就是为每个 IOC 容器创建唯一的一个 Bean 实例</li><li>Prototype，针对每个 getBean 请求，容器都会单独创建一个 Bean 实例（使用 Prototype 作用域需要经过仔细思考，毕竟频繁创建和销毁 Bean 是有明显开销的）</li></ul><p>如果是 Web 容器，则支持另外三种作用域：</p><ul><li>Request，为每个 HTTP 请求创建单独的 Bean 实例</li><li>Session，很显然 Bean 实例的作用域是 Session 范围</li><li>GlobalSession，GlobalSession提供一个全局性的 HTTP Session</li></ul><h4 id="Autowire和-Resource的区别？"><a href="#Autowire和-Resource的区别？" class="headerlink" title="@Autowire和@Resource的区别？"></a>@Autowire和@Resource的区别？</h4><table><thead><tr><th>对比项</th><th>@Autowire</th><th>@Resource</th></tr></thead><tbody><tr><td>注解来源</td><td>Spring注解</td><td>JDK注解(JSR-250标准注解，属于J2EE)</td></tr><tr><td>装配方式</td><td>优先按类型（by type）</td><td>优先按名称（by name）</td></tr><tr><td>属性</td><td>required</td><td>name、type</td></tr><tr><td>作用范围</td><td>字段、setter方法、构造器</td><td>字段、setter方法</td></tr></tbody></table><h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h4 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h4><ul><li>应用层</li><li>表示层：数据压缩，加密等</li><li>会话层：会话的创建和管理</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><h4 id="经典五层"><a href="#经典五层" class="headerlink" title="经典五层"></a>经典五层</h4><ul><li>应用层：HTTP，DNS</li><li>传输层：TCP，UDP</li><li>网络层：为主机提供数据传输服务，传输层是为主机中的进程提供传输服务</li><li>数据链路层：主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务</li><li>物理层：传输媒介</li></ul><h4 id="TCP-x2F-IP四层"><a href="#TCP-x2F-IP四层" class="headerlink" title="TCP&#x2F;IP四层"></a>TCP&#x2F;IP四层</h4><ul><li>应用层</li><li>传输层</li><li>网际层</li><li>网路接口层</li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h4><p>DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务，域名具有树状结构，从上到下依次为：根域名、顶级域名、二级域名</p><h4 id="FTP文件传输协议"><a href="#FTP文件传输协议" class="headerlink" title="FTP文件传输协议"></a>FTP文件传输协议</h4><p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件</p><h4 id="DHCP动态主机配置协议"><a href="#DHCP动态主机配置协议" class="headerlink" title="DHCP动态主机配置协议"></a>DHCP动态主机配置协议</h4><p>用户不再需要去手动配置 IP 地址等信息</p><h4 id="TELNET远程登录协议"><a href="#TELNET远程登录协议" class="headerlink" title="TELNET远程登录协议"></a>TELNET远程登录协议</h4><h4 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h4><p>一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议<br>邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP</p><h4 id="Web请求"><a href="#Web请求" class="headerlink" title="Web请求"></a>Web请求</h4><p><a href="https://www.cnblogs.com/xianyulaodi/p/6547807.html">在网页中输入url后发生了什么？</a></p><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道</p><h4 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h4><ul><li><p>用户数据报协议 UDP（User Datagram Protocol）：无连接，没有拥塞控制，面向报文的；支持一对一、一对多、多对一和多对多的交互通信</p></li><li><p>传输控制协议 TCP（Transmission Control Protocol）：面向连接的，提供可靠的交互，有流量控制、拥塞控制，提供全双工通信，面向字节流，每一条TCP通信只能是一对一的</p><h4 id="TCP和UDP报文"><a href="#TCP和UDP报文" class="headerlink" title="TCP和UDP报文"></a>TCP和UDP报文</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114243554-f9f7626f-db8a-4d0b-bfcd-04b400553eb9.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=279&id=uf85ca9a2&margin=%5Bobject%20Object%5D&name=UDP%E6%8A%A5%E6%96%87.png&originHeight=306&originWidth=569&originalType=binary&ratio=1&rotation=0&showTitle=false&size=107210&status=done&style=none&taskId=uf92b58df-ff47-4006-89f6-fc4394f69ff&title=&width=518" alt="UDP报文.png"><br>UDP首部只有8个字节：</p></li><li><p>源端口</p></li><li><p>目的端口</p></li><li><p>长度</p></li><li><p>校验和<br>分别占两个字节</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114268160-3e368838-c85c-4ebe-9de8-e7c47a46e586.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=419&id=ubaf30aef&margin=%5Bobject%20Object%5D&name=TCP%E6%8A%A5%E6%96%87.png&originHeight=493&originWidth=691&originalType=binary&ratio=1&rotation=0&showTitle=false&size=142509&status=done&style=none&taskId=u71475384-adb2-4f42-9cb1-b04531bbe01&title=&width=587" alt="TCP报文.png"><br>TCP头部最少20个字节，重点：</p><ul><li>序号：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401</li><li>确认号：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701</li><li>数据偏移：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度</li><li>确认ACK：当 ACK&#x3D;1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1</li><li>同步SYN：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1</li><li>终止FIN：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接</li><li>窗口：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的</li></ul><h4 id="TCP建立连接的三次握手"><a href="#TCP建立连接的三次握手" class="headerlink" title="TCP建立连接的三次握手"></a>TCP建立连接的三次握手</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114300903-efa4c68c-341c-4570-ad24-b66edc2f95db.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=301&id=u2c12b962&margin=%5Bobject%20Object%5D&name=%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png&originHeight=350&originWidth=614&originalType=binary&ratio=1&rotation=0&showTitle=false&size=92312&status=done&style=none&taskId=uf96588ed-1c80-44b6-b6f0-ea2028b24ff&title=&width=528" alt="三次握手.png"><br>假设 A 为客户端，B 为服务器端：</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求</li><li>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0，选择一个初始的序号 x</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也选择一个初始的序号 y</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1</li><li>B 收到 A 的确认后，连接建立</li></ul><p>三次握手的原因：<br>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接；并且确保只建立一个连接</p><p>《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”</p><h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114336621-09b7e6d9-e5b3-4ce0-850e-e0e9a9bd854d.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=345&id=uddf4127a&margin=%5Bobject%20Object%5D&name=TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png&originHeight=377&originWidth=548&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116016&status=done&style=none&taskId=u1a0722de-40e9-48cd-bd3a-2d15bfcd8cc&title=&width=501" alt="TCP四次挥手.png"><br>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1：</p><ul><li>A 发送连接释放报文，FIN&#x3D;1</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据</li><li>当 B 不再需要连接时，发送连接释放报文，FIN&#x3D;1</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接</li><li>B 收到 A 的确认后释放连接</li></ul><p>四次挥手的原因：<br>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文</p><p>TIME_WAIT：<br>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文<h4 id="TCP如何可靠传输？"><a href="#TCP如何可靠传输？" class="headerlink" title="TCP如何可靠传输？"></a>TCP如何可靠传输？</h4>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段<br>一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，超时时间 RTO 应该略大于 RTTs<h4 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h4>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小</li></ul><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114370101-e378b884-acd6-4ee9-9731-2a988d920af4.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=252&id=u3120333e&margin=%5Bobject%20Object%5D&name=TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.png&originHeight=304&originWidth=742&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141108&status=done&style=none&taskId=u0203e10b-384b-4387-8c6a-ef64660f8fa&title=&width=614" alt="TCP滑动窗口.png"></p><h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据</p><h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率</p><p>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复，发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口</p><p>慢开始与拥塞避免：<br>发送的最初执行慢开始，令 cwnd &#x3D; 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1</p><p>如果出现了超时，则令 ssthresh &#x3D; cwnd &#x2F; 2，然后重新执行慢开始</p><p>快重传与快恢复：<br>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh &#x3D; cwnd &#x2F; 2 ，cwnd &#x3D; ssthresh，注意到此时直接进入拥塞避免</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh</p><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务<br>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络<br>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h4 id="IP报文"><a href="#IP报文" class="headerlink" title="IP报文"></a>IP报文</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114396304-55df5c5b-95e7-439f-a41a-ca1cf4c35bc3.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=330&id=ufe93a412&margin=%5Bobject%20Object%5D&name=IP%E6%8A%A5%E6%96%87.png&originHeight=362&originWidth=655&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116864&status=done&style=none&taskId=u5e8f5d61-2699-4c24-81f9-ce34e702013&title=&width=598" alt="IP报文.png"><br>主要的变量：</p><ul><li>版本 : 有 4（IPv4）和 6（IPv6）两个值</li><li>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充</li><li>区分服务 : 用来获得更好的服务，一般情况下不使用</li><li>总长度 : 包括首部长度和数据部分长度</li><li>生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报</li><li>协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等</li><li>首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量</li><li>标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符</li><li>片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节</li></ul><h4 id="IP地址编址方式"><a href="#IP地址编址方式" class="headerlink" title="IP地址编址方式"></a>IP地址编址方式</h4><ol><li>分类<br>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114423825-2c2f9280-d3dd-4046-9f57-3ac442e6cfa0.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc3a9dca0&margin=%5Bobject%20Object%5D&name=IP%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86.png&originHeight=281&originWidth=477&originalType=binary&ratio=1&rotation=0&showTitle=false&size=78409&status=done&style=none&taskId=u1da6eab9-b4cb-42a1-b13e-27ff4adb11e&title=" alt="IP地址划分.png"></p><ol start="2"><li>子网划分</li><li>无分类<br>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化</li></ol><h4 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h4><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信<br>ARP 实现由 IP 地址得到 MAC 地址<br>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表<br>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射</p><h4 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h4><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议<br>ICMP 报文分为差错报告报文和询问报文</p><ol><li>Ping<br>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。<br>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</li><li>Traceroute<br>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。<br>Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</li></ol><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><h4 id="网络地址转换NAT"><a href="#网络地址转换NAT" class="headerlink" title="网络地址转换NAT"></a>网络地址转换NAT</h4><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP</p><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ol><li>封装成帧<br> 将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束</li><li>透明传输</li></ol><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114463128-076d2156-0dc6-4090-aeb8-dd263206da1d.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=225&id=uadc8975a&margin=%5Bobject%20Object%5D&name=HTTP%E5%8D%8F%E8%AE%AE.png&originHeight=267&originWidth=609&originalType=binary&ratio=1&rotation=0&showTitle=false&size=94095&status=done&style=none&taskId=ufda36809-13eb-4a38-a721-bfcfd72a571&title=&width=513" alt="HTTP协议.png"></p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>GET请求：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/adcreate/application?application_id=1497002130351668</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>localhost:3000<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>no-cache<br><span class="hljs-attribute">Postman-Token</span><span class="hljs-punctuation">: </span>b3c12acc-642b-f772-7960-fbf0cad53f8b<br></code></pre></td></tr></table></figure><p>POST请求：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">POST</span> /aduser/login HTTP/<span class="hljs-number">1</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">Host</span>: localhost:<span class="hljs-number">3000</span><br><span class="hljs-attribute">Content</span>-Type: application/x-www-form-urlencoded<br><span class="hljs-attribute">Cache</span>-Control: no-cache<br><span class="hljs-attribute">Postman</span>-Token: aeaca64f-ba58-<span class="hljs-number">633</span>d-<span class="hljs-number">07</span>bb-dc977c2390f9<br><span class="hljs-attribute">account</span>=tangjing&amp;password=<span class="hljs-number">123456</span>  //POST传参<br></code></pre></td></tr></table></figure><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114490201-6b07d836-b781-4082-930d-a62c82094dac.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=220&id=u20a31796&margin=%5Bobject%20Object%5D&name=HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png&originHeight=259&originWidth=699&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20400&status=done&style=none&taskId=ueb65f523-9212-4e7b-9b18-95687cd3445&title=&width=594" alt="HTTP响应报文.png"></p><h4 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h4><h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><p>获取资源</p><h5 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h5><p>获取报文首部，和 GET 方法一样，但是不返回报文实体主体部分</p><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>POST 主要用来传输数据，而 GET 主要用来获取资源</p><h5 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h5><p>上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</p><h5 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h5><p>对资源进行部分修改，PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改</p><h5 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h5><p>删除文件，与 PUT 功能相反，并且同样不带验证机制</p><h5 id="GET-和-POST-比较？"><a href="#GET-和-POST-比较？" class="headerlink" title="GET 和 POST 比较？"></a>GET 和 POST 比较？</h5><ul><li>传参，GET为URL传参，POST为body传参</li><li>安全。GET是获取资源，不会改变资源，因此相对于POST较安全</li><li>幂等性（幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的），POST没有幂等性</li><li>可缓存性，POST 在多数情况下不可缓存的</li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><table><thead><tr><th>状态码</th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><h4 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h4><ul><li><p>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</p><h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4></li><li><p>200 OK</p></li><li><p>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用</p></li><li><p>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容</p></li></ul><h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><ul><li>301 Moved Permanently ：永久性重定向</li><li>302 Found ：临时性重定向（都是资源的地址被修改了，需要重定向一下）</li><li>304，资源未修改，不需要重复请求了</li><li>305，必须通过代理访问资源，代理的地址在Response 的Location中</li></ul><h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><ul><li>400 Bad Request ：请求报文中存在语法错误</li><li>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败</li><li>403 Forbidden ：请求被拒绝</li><li>404 Not Found</li></ul><h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h4><ul><li>500 Internal Server Error ：服务器正在执行请求时发生错误</li><li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</li></ul><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td>Date</td><td>创建报文的日期时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器的相关信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept</td><td>用户代理可处理的媒体类型</td></tr><tr><td>Accept-Charset</td><td>优先的字符集</td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td></tr><tr><td>Accept-Language</td><td>优先的语言（自然语言）</td></tr><tr><td>Authorization</td><td>Web 认证信息</td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td></tr><tr><td>From</td><td>用户的电子邮箱地址</td></tr><tr><td>Host</td><td>请求资源所在服务器</td></tr><tr><td>If-Match</td><td>比较实体标记（ETag）</td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记（与 If-Match 相反）</td></tr><tr><td>If-Range</td><td>资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证信息</td></tr><tr><td>Range</td><td>实体的字节范围请求</td></tr><tr><td>Referer</td><td>对请求中 URI 的原始获取方</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td>User-Agent</td><td>HTTP 客户端程序的信息</td></tr></tbody></table><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否接受字节范围请求</td></tr><tr><td>Age</td><td>推算资源创建经过时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td>Location</td><td>令客户端重定向至指定 URI</td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr><tr><td>Retry-After</td><td>对再次发起请求的时机要求</td></tr><tr><td>Server</td><td>HTTP 服务器的安装信息</td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td></tr><tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr></tbody></table><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><table><thead><tr><th>首部字段名</th><th>说明</th></tr></thead><tbody><tr><td>Allow</td><td>资源可支持的 HTTP 方法</td></tr><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td></tr><tr><td>Content-Length</td><td>实体主体的大小</td></tr><tr><td>Content-Location</td><td>替代对应资源的 URI</td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td></tr><tr><td>Content-Range</td><td>实体主体的位置范围</td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table><h3 id="HTTP应用"><a href="#HTTP应用" class="headerlink" title="HTTP应用"></a>HTTP应用</h3><p>短连接与长连接：<br>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信</p><ul><li>从 HTTP&#x2F;1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close；</li><li>在 HTTP&#x2F;1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive</li></ul><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装</li><li>无法证明报文的完整性，报文有可能遭篡改<br>HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPs 使用了隧道进行通信。<br>通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</li></ul><p>开销：</p><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用</li></ul><h3 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h3><h4 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h4><p>HTTP&#x2F;2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114530619-9e7e63f5-771d-4da2-b3d1-edea58b28b75.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uae3ea938&margin=%5Bobject%20Object%5D&name=%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8A%A5%E6%96%87.png&originHeight=317&originWidth=372&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35943&status=done&style=none&taskId=uf1dc494c-5e3f-4847-b274-a04e82f625d&title=" alt="二进制报文.png"><br>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）</p><h4 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h4><p>HTTP&#x2F;2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端</p><h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p>HTTP&#x2F;1.1 的首部带有大量信息，而且每次都要重复发送</p><p>HTTP&#x2F;2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输</p><p>不仅如此，HTTP&#x2F;2.0 也使用 Huffman 编码对首部字段进行压缩</p><h3 id="HTTP1-1新特性"><a href="#HTTP1-1新特性" class="headerlink" title="HTTP1.1新特性"></a>HTTP1.1新特性</h3><ul><li>默认是长连接</li><li>支持流水线，在一个TCP连接内，多个HTTP请求可以并行，客户端不用等待上一次请求结果返回，就可以发出下一次请求</li><li>支持同时打开多个 TCP 连接</li><li>支持虚拟主机</li><li>新增状态码 100</li><li>支持分块传输编码</li><li>新增缓存处理指令 max-age</li></ul><p><a href="https://www.jianshu.com/p/52d86558ca57">如何优雅的谈论HTTP／1.0／1.1／2.0</a></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="并发-amp-并行"><a href="#并发-amp-并行" class="headerlink" title="并发&amp;并行"></a>并发&amp;并行</h4><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令；并行需要硬件支持，如多流水线或者多处理器</p><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>共享是指系统中的资源可以被多个并发进程共同使用，共享方式：</p><ul><li>互斥共享：互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问</li><li>同时共享</li></ul><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><p>虚拟技术把一个物理实体转换为多个逻辑实体，主要有两种：</p><ul><li>时分复用技术：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换</li><li>空分复用技术：比如虚拟内存，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间和物理内存使用页进行交换，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中</li></ul><h3 id="操作系统的基本功能？"><a href="#操作系统的基本功能？" class="headerlink" title="操作系统的基本功能？"></a>操作系统的基本功能？</h3><ul><li>进程管理：进程控制、进程同步、进程通信、死锁处理、处理机调度等</li><li>内存管理：内存分配、地址映射、内存保护与共享、虚拟内存等</li><li>文件管理：文件存储空间的管理、目录管理、文件读写管理和保护等</li><li>设备管理：完成用户的 I&#x2F;O 请求，方便用户使用各种设备，并提高设备的利用率；主要包括缓冲管理、设备分配、设备处理、虛拟设备等</li></ul><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><h4 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h4><ul><li>进程：操作系统分配和管理资源的基本单位；有自己的地址空间，有多个线程</li><li>线程：是CPU调度的基本单位；一个进程中的多个线程共享进程资源</li></ul><h4 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h4><ul><li>就绪：等待被调度</li><li>运行</li><li>阻塞：等待资源</li></ul><h4 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h4><h5 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h5><ul><li>先来先服务，first-come first-serverd（FCFS）</li><li>短作业优先，shortest job first（SJF）：防止长作业饿死</li><li>最短剩余时间优先，shortest remaining time next（SRTN）</li></ul><h5 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h5><ul><li>时间片轮转</li><li>优先级调度：给进程设置优先级</li><li>多级反馈队列：相当于时间片+优先级</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114575142-e82ac0b6-9669-471c-8d85-dcc43506599c.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9462d5a4&margin=%5Bobject%20Object%5D&name=%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97.png&originHeight=281&originWidth=387&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24188&status=done&style=none&taskId=uc3fc554f-aa71-442a-97a3-fe6a1daa156&title=" alt="多级反馈队列.png"><br>每个队列的优先级别都不同，上面的高，下面的低</p><h4 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h4><h5 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h5><p>对临界资源进行访问的代码块叫做临界区；在同一个时刻，只有一个进程能进入临界区</p><h5 id="同步-amp-互斥"><a href="#同步-amp-互斥" class="headerlink" title="同步&amp;互斥"></a>同步&amp;互斥</h5><ul><li>同步：多个进程按顺序执行</li><li>互斥：多个进程在同一时刻只有一个能进入临界区</li></ul><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作</p><ul><li>down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0</li><li>up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作</li></ul><p>如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁</p><h4 id="进程间的通信？"><a href="#进程间的通信？" class="headerlink" title="进程间的通信？"></a>进程间的通信？</h4><ul><li>无名管道，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系；无名管道的建立就是通过fork()函数（类似克隆）来建立一个子进程，然后父子进程就可以通过管道</li><li>有名管道：去除了管道父子进程的限制</li><li>消息队列：存放消息的链表，一个存消息，一个读消息</li><li>共享内存：最快的通信方式</li><li>信号量：控制多个进程对共享资源的访问，比如临界区</li><li>Socket：和其它不同，套接字可用于两台不同机器的进程进行通信</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁的必要条件（重点）：</p><ul><li>互斥：多个进程对资源的访问是互斥的；不可同时占有</li><li>占有和等待：已经占有某个资源的进程还可以尝试获取别的资源</li><li>不可强占：除非一个进程自己释放资源，其它线程不可强行获取</li><li>循环等待：A等B释放资源，B等C释放资源，C等A释放资源</li></ul><h4 id="破坏死锁"><a href="#破坏死锁" class="headerlink" title="破坏死锁"></a>破坏死锁</h4><p>强制破坏死锁的任一条件；例如强制杀死进程</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><ul><li>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存</li><li>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令</li></ul><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><ul><li>最佳置换算法</li><li>最近最久未使用，LRU</li><li>最近未使用</li><li>FIFO先进先出</li><li>第二次机会算法</li><li>时钟</li></ul><p>未完待续…</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul><li>开闭原则，简称OCP。即软件实体对扩展是开放的，对修改是闭合的</li><li>里氏替换原则，简称LSP。即任何父类出现的地方都可以被子类代替</li><li>依赖倒转原则，简称DIP。即要依赖于抽象而不要依赖于具体实现</li><li>接口隔离原则，简称ISP。即为客户端尽可能提供小的、单独的接口，而不是提供更大的接口</li><li>组合&#x2F;聚合复用原则，简称CARP。即尽量使用组合、聚合来达到复用的目的，而不是利用继承</li><li>迪米特法则，简称LOD，讲的是一个软件实体应当与尽可能少的其他软件实体发生相互作用</li></ul><h3 id="挑几个重点的"><a href="#挑几个重点的" class="headerlink" title="挑几个重点的"></a>挑几个重点的</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>标准写法，双重校验 + volatile</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//双重校验，线程安全 [推荐]</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton7</span> &#123;<br>       <span class="hljs-comment">//volatile关键字可以避免instance = new Singleton7()的重排序</span><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton7</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>       <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton7</span><span class="hljs-params">()</span> &#123;<br><br>       &#125;<br><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton7 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">synchronized</span> (Singleton7.class) &#123;<br>                   <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>)<br>                       instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton7</span>();<br><br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">return</span> instance;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂三兄弟：简单工厂模式，工厂方法模式，抽象工厂</p><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>将处理行为的对象连成一条链，并沿着这条链发送该请求。当前对象的级别不够处理这条请求，就把请求抛给上一级处理</p><ul><li>拦截器</li></ul><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>一对多的依赖关系，n个观察者观察一个被观察者，当被观察者的对象发生改变时，消息会通知给所有的观察者</p><ul><li>微信公众订阅号</li></ul><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>想用别人的类，但是又不想改变我原有的设计格式。直接用别人的实例对象，用自己的函数内部嵌套别人的对象.函数</p><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活</p><ul><li>Java中IO流的设计</li></ul><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>把被代理的对象拿过来使用，并且在使用前后可以增加一些新的功能<br>和装饰模式的区别？</p><ul><li>代理，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制</li><li>装饰，偏重对原对象功能的扩展，扩展后的对象仍是是对象本身</li></ul><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>自己写一个代理模式的那种</p><h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>代理类实现InvocationHandler，代理一个已经实现接口的类。通过字节码框架动态生成字节码，并且在defineclass加载类后，获取代理类的实例。代理的是同名的方法</p><h5 id="CGlib代理"><a href="#CGlib代理" class="headerlink" title="CGlib代理"></a>CGlib代理</h5><p>也是通过字节码生成框架生成代理类的字节码，不同的是被代理的类不需要实现接口；生成的代理类是业务类的子类，通过重写业务方法进行代理</p><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>如果对象存在，则直接使用。如果不存在，则把他放入对象池中</p><ul><li>常量池</li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114610141-6503e157-f429-41a5-bdf2-c0fd3c003202.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=290&id=ue7441120&margin=%5Bobject%20Object%5D&name=%E6%8E%92%E5%BA%8F.png&originHeight=325&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=21345&status=done&style=none&taskId=ue046904c-c164-428a-be4d-97d41ba97ae&title=&width=494" alt="排序.png"></p><h3 id="快排什么时候最差？"><a href="#快排什么时候最差？" class="headerlink" title="快排什么时候最差？"></a>快排什么时候最差？</h3><p>快排的效率和选择的基准有很大的关系：</p><ul><li>如果划分是平衡的，那么快速排序算法性能与归并排序一样</li><li>如果划分时不平衡的，那么快速排序的性能就接近于插入排序了</li></ul><p>导致最差的情况：</p><ul><li>在分解时每次选取的主元素为最小元素</li><li>在分解时每次选取的主元素为最大元素</li></ul><p>为了防止最差的情况，每次基准随机取值；或者取当前中值：（最大值+最小值）&#x2F;2，这个值不存在就取离中值最近的值</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p>出自牛客：</p><blockquote><p>不稳定的排序算法有：快、希、选、堆。（记忆：找到工作就可以“快些选一堆”美女来玩了（并不能））</p></blockquote><h2 id="数据库和MySQL"><a href="#数据库和MySQL" class="headerlink" title="数据库和MySQL"></a>数据库和MySQL</h2><p>MySQL和数据库理论知识</p><h3 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h3><ul><li>原子性，不可分割，要么全部提交成功，要么回滚失败</li><li>一致性，数据库在执行事务前后从一个状态转化到另一个状态；<strong>一致性主要关注中间数据的可见性，中间状态的数据对外部不可见</strong>，只有最初状态和最终状态的数据对外可见</li><li>隔离性，一个事务所做的修改在最终提交以前，对其它事务是不可见的</li><li>持久性，一旦事务提交，则其所做的修改将会永远保存到数据库中</li></ul><h4 id="事务的实现原理"><a href="#事务的实现原理" class="headerlink" title="事务的实现原理"></a>事务的实现原理</h4><p>隔离性，通过锁来实现的；<br>原子性、一致性和持久性由数据库的 <strong>redo log</strong> 和 <strong>undo log</strong> 实现；redo log：数据缓冲和事务持久，做了哪些操作，都可查<br>事务的回滚和MVCC版本控制，需要undo日志</p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>未提交读，所谓的脏读，A事务还没提交，B事务读到了脏数据</li><li>提交读，解决了上一个问题；但是存在着幻读，即不可重复读，A连续读两次，但在读中间B插入修改数据，造成A幻读</li><li>可重复读，确保了同一个事务多次读数据能读到同样的数据行；这是MySQL的默认的隔离级别</li><li>可串行化，强制事务串行执行，也就不存在并发的问题了，但是效率很低下</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>博客：<a href="https://blog.csdn.net/ljfrocky/article/details/80379328">聊一聊MySQL里的锁和MVCC</a></p><h4 id="锁的思想：乐观锁和悲观锁"><a href="#锁的思想：乐观锁和悲观锁" class="headerlink" title="锁的思想：乐观锁和悲观锁"></a>锁的思想：乐观锁和悲观锁</h4><p>两者的区别：</p><ul><li>乐观锁，不加锁，大多是基于数据的版本号实现的，给每个数据加个版本号，现在A事务提交，若当前版本&gt;数据库已存在的版本，那么可以提交，负责就认为这个数据被别的事务修改过了，回滚；好处是不加锁，性能有所提高，但也有安全隐患</li><li>悲观锁：对数据的操作都要加锁，安全度很高，但是性能开销也大</li></ul><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>MySQL的InnoDB引擎通过MVCC（多版本并发控制）来实现可重复读和读已提交。本质也是通过版本号实现的一种乐观锁。</p><h4 id="锁的粒度：表级锁和行级锁"><a href="#锁的粒度：表级锁和行级锁" class="headerlink" title="锁的粒度：表级锁和行级锁"></a>锁的粒度：表级锁和行级锁</h4><p>一般来说，锁的粒度越小，冲突越少，整个系统的并发性越高</p><ul><li>MyISAM仅支持表级锁</li><li>InnoDB引擎支持行级锁</li></ul><h4 id="真正的锁：共享锁和排它锁"><a href="#真正的锁：共享锁和排它锁" class="headerlink" title="真正的锁：共享锁和排它锁"></a>真正的锁：共享锁和排它锁</h4><ul><li>当事务A加了共享锁之后，其它的事务只能加共享锁；持有共享锁的事务，只能读，不能修改数据</li><li>当事务A加了排它锁后，只有事务A可以修改和读取数据；其它事务不能加任何锁，直到A释放</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>采用B+树，查找：在根节点进行二分查找；找不到再递归，在子节点上依次查找，数据结构：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653114642953-64d31867-6ed6-4dfd-ba9f-cf27be540869.png#clientId=u70849440-5982-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u51ab42a1&margin=%5Bobject%20Object%5D&name=B%E5%8A%A0%E6%A0%91.png&originHeight=191&originWidth=543&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12517&status=done&style=none&taskId=u32933ab8-8db8-4af9-b652-9105e5a983c&title=" alt="B加树.png"></p><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><ul><li>所有的节点为红色或者黑色</li><li>根节点和空的叶子节点为黑色</li><li>红节点的子节点为黑色</li><li>从任意节点到其每个叶子节点的路径经过相同的黑节点(最长路径长度不超过最短路径长度的2倍)</li></ul><p>红黑树对比B+树：</p><ul><li>更少的查找次数，相同节点下，B+树的高度更低，查找效率更高</li><li>利用磁盘预读特性：操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据，数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I&#x2F;O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入</li></ul><p><a href="https://www.cnblogs.com/scu-cjx/p/8629215.html">查找树效率对比</a></p><h5 id="几种树的查询、删除效率"><a href="#几种树的查询、删除效率" class="headerlink" title="几种树的查询、删除效率"></a>几种树的查询、删除效率</h5><p>二叉搜索树BST：</p><ul><li>查找效率最好的情况是O(logN)，最差的情况会退化成O(N)</li><li>插入和删除仅需要微调或者不调整，时间复杂度和查找差不多</li></ul><p>平衡二叉树AVL：</p><ul><li>查询效率最好，O(logN)；因为保证了严格的平衡条件</li><li>插入代价：每次只需要旋转一次，因此插入代价也在O(logN)</li><li>删除代价很高，必须递归检查是否平衡，时间复杂度在O(2logN)</li></ul><p>红黑树：<br>介于BST和AVL之间，牺牲插入、删除的代价，来换取O(logN)的查询效率</p><ul><li>查询效率基本维持在O(logN)，但是最差的情况下会比O(logN)差</li><li>插入和删除代价在O(logN)，小于AVL树</li><li>Java中TreeMap就是一颗红黑树</li><li>插入一个节点最多旋转2次，删除一个节点最多旋转3次</li></ul><h4 id="hash索引"><a href="#hash索引" class="headerlink" title="hash索引"></a>hash索引</h4><p>当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引：</p><ul><li>只支持精确查找，无法用于部分查找和范围查找</li></ul><h4 id="聚簇-amp-amp-非聚簇索引"><a href="#聚簇-amp-amp-非聚簇索引" class="headerlink" title="聚簇&amp;&amp;非聚簇索引"></a>聚簇&amp;&amp;非聚簇索引</h4><ul><li>聚簇索引指的是数据文件和索引文件是同一个文件，例如InnoDB中表的主键就是聚簇索引；一个表只能有一个聚簇索引</li><li>非聚簇索引，索引中存放的不是数据本身，而是指向数据地址的指针；主要用于MyISAM存储引擎中</li></ul><h4 id="主键索引和非主键索引"><a href="#主键索引和非主键索引" class="headerlink" title="主键索引和非主键索引"></a>主键索引和非主键索引</h4><p>主键索引和非主键索引是有区别的：<br>主键索引存放的值是<strong>整行字段的数据</strong><br>非主键索引上存放的值不是整行字段的数据，而且<strong>存放主键字段的值</strong>，因此非主键索引要走两遍扫描，第一次扫描出主键，再走主键索引</p><h4 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h4><ol><li>当一个字段更新频率较低，但查询频率较高，建议使用索引</li><li>经常同时存取多列，可以考虑使用组合索引</li><li>组合索引的前导列如果不在查询条件中则该索引不会被使用</li></ol><h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><ul><li><p>直接索引和间接索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>直接索引<br><span class="hljs-keyword">create</span> index name1_index <span class="hljs-keyword">on</span> table1(column1)<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>间接索引：定义主键或者唯一性约束，可以自动创建索引<br></code></pre></td></tr></table></figure></li><li><p>唯一性索引：保证索引列中的数据都是唯一的</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">unique</span> coustered index name2_index <span class="hljs-keyword">on</span> table1(column1)<br></code></pre></td></tr></table></figure></li><li><p>组合&#x2F;复合索引：对多个字段进行联合创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> index name3_index <span class="hljs-keyword">on</span> table1(column1,column2)<br></code></pre></td></tr></table></figure></li><li><p>聚簇索引和非聚簇索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> coustered index name2_index <span class="hljs-keyword">on</span> table1(column1)<br><span class="hljs-keyword">create</span> uncoustered index name2_index <span class="hljs-keyword">on</span> table1(column1)<br></code></pre></td></tr></table></figure></li></ul><h5 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h5><ul><li>查询条件中含有or</li><li>对于组合索引，若第一列不在查询条件中</li><li>like以%开头</li><li>如果列类型是字符串，查询条件的时候没有用单引号引起来</li><li>MySQL 引擎认为全表扫描比索引更快的情况</li><li>where中有表达式，函数等</li></ul><p>比如<code>where c - 1 = 1000</code>，这样导致索引失效；改为<code>where c = 1000 + 1</code>；<br>还有用了一些函数导致索引失效</p><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>MySQL的两个存储引擎MyISAM和InnoDB：</p><ul><li>InnoDB是事务安全的，MyISAM不是</li><li>InnoDB支持行级锁，而MyISAM仅表锁</li><li>索引的区别，聚簇和非聚簇</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>MyISAM，它管理非事务的表，提供高速的存储和检索，以及全文的搜索能力，如果场景下查询的业务很多，大量的select语句，那么MyISAM是更好的选择</p><p>InnoDB用于事务处理应用程序，如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能</p><h3 id="常用的SQL"><a href="#常用的SQL" class="headerlink" title="常用的SQL"></a>常用的SQL</h3><h4 id="几种删除的区别"><a href="#几种删除的区别" class="headerlink" title="几种删除的区别"></a>几种删除的区别</h4><ul><li>drop：删除表</li><li>truncate：清空表的数据，表本身还在</li><li>delete：删除表的某些数据，配合where做筛选</li></ul><h4 id="几种连接的区别"><a href="#几种连接的区别" class="headerlink" title="几种连接的区别"></a>几种连接的区别</h4><ul><li><p>内连接：将两个表取交集，会忽略掉两个表对应不起来的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.xxx<span class="hljs-operator">=</span>table2.xxx<br></code></pre></td></tr></table></figure></li><li><p>左连接：left左边的表取全部数据，右边的表缺少的数据补NULL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.xxx<span class="hljs-operator">=</span>table2.xxx<br></code></pre></td></tr></table></figure></li><li><p>右连接：和左连接相反</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">right</span> <span class="hljs-keyword">join</span> table2 <span class="hljs-keyword">on</span> table1.xxx<span class="hljs-operator">=</span>table2.xxx<br></code></pre></td></tr></table></figure></li></ul><h2 id="Linux指令"><a href="#Linux指令" class="headerlink" title="Linux指令"></a>Linux指令</h2><h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><p>创建用户并生成对应的home文件夹：<br>useradd -d &#x2F;home&#x2F;zc -m zc</p><p>修改用户密码：<br>passwd zc</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看kafka对应的进程号<br>ps aux | grep kafka<br>ps -ef | grep kafka</p><p>查看端口对应的进程号<br>lsof  -i:9092</p><p>根据进程号查看对应的信息，比如端口啥的<br>netstat -anop | grep PID</p><p>根据进程号杀死进程<br>kill -9 21804</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p><a href="https://www.jb51.net/article/135411.htm">top命令详解</a><br>top 命令主要用于查看进程的相关信息，同时它也会提供系统平均负载，cpu 信息和内存信息：</p><ul><li>系统平均负载</li><li>任务信息汇总</li><li>CPU信息</li><li>内存信息</li><li>任务详情</li></ul><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>ping是探测主机和主机之间能否通信；使用的是ICMP协议-&gt;IP协议</p><p>ICMP协议规定：目的主机必须返回ICMP包给源主机，如果在一定时间内没有返回，则认为目的主机不可达；IP协议是无连接的、不可靠的数据报协议</p><h4 id="ping-192-168-1-5的细节过程？"><a href="#ping-192-168-1-5的细节过程？" class="headerlink" title="ping 192.168.1.5的细节过程？"></a>ping 192.168.1.5的细节过程？</h4><ol><li>生成ICMP报文，交给IP层处理，IP层再将源主机和目的主机的地址打包+控制信息，生成IP报文</li><li>然后需要找到目的地址的MAC地址；先去ARP缓存去找，找不到则广播，获取MAC地址（找不到则返回超时信息）</li><li>再将MAC地址封装成数据链路包，交给数据链路层；发送给目的地址</li><li>目的地址收到报文，再以相同的方式返回给源地址</li></ol><p>ARP协议：存放了IP地址到MAC地址的映射</p><h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>侦测由源主机到目的主机所经过的路由的情况的重要工具；ping受到IP头的限制（IP首部字段最多只能放9个IP地址），ping不能完全记录所经过的路由器</p><p>Traceroute原理：</p><ol><li>首先给目的主机发送一个TTL&#x3D;1（TTL指生存时间）的udp数据包，而经过的第一个路由器收到这个数据包之后，自动把TTL减去1，而TTL变为0之后，路由器就将这个数据包抛弃，并同时产生一个主机不可达的ICMP超时数据报给主机</li><li>主机收到这个ICMP数据报以后，会发送一个TTL&#x3D;2的数据报给目的主机，然后刺激第二个路由器给主机发送ICMP数据报，如此反复，直到到达目的主机。这样Traceroute就可以拿到所有路由器的IP</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>校招</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些常用的 Linux 命令</title>
    <link href="/2018/08/17/Linux/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84-Linux-%E5%91%BD%E4%BB%A4/"/>
    <url>/2018/08/17/Linux/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84-Linux-%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><h2 id="1-1-目录含义"><a href="#1-1-目录含义" class="headerlink" title="1.1 目录含义"></a>1.1 目录含义</h2><p>Linux 各个目录的含义：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653666743298-cee648bd-150b-4ed4-9bd8-08c990663b6d.png#clientId=uadd86808-607a-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue396429c&margin=%5Bobject%20Object%5D&name=linux_dir1.PNG&originHeight=270&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=123385&status=done&style=none&taskId=u446e369f-d8a2-440b-bbf1-e600eb968e2&title=" alt="linux_dir1.PNG"><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653666743331-3f6a0c11-6616-45e6-87cf-e6ab0b753b08.png#clientId=uadd86808-607a-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue129712d&margin=%5Bobject%20Object%5D&name=linux_dir2.PNG&originHeight=284&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=161278&status=done&style=none&taskId=ua9bbd3c0-9ba9-4839-9305-2671294c437&title=" alt="linux_dir2.PNG"><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653666743344-ac841cf3-4bd3-4fee-91b1-02827da43db6.png#clientId=uadd86808-607a-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc3e4baea&margin=%5Bobject%20Object%5D&name=linux_dir3.PNG&originHeight=315&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=143393&status=done&style=none&taskId=ub046106c-8325-46a6-af6c-ebbc2d2f2f4&title=" alt="linux_dir3.PNG"></p><h2 id="1-2-命令规则"><a href="#1-2-命令规则" class="headerlink" title="1.2 命令规则"></a>1.2 命令规则</h2><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">命令 [-选项] [参数]<br>举例： ls -la /etc<br></code></pre></td></tr></table></figure><p>简化选项与完整选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-a 等于 --all<br>简化选项：- 加 简化字母<br>完整选项：-- 加 完整字母<br></code></pre></td></tr></table></figure><h1 id="2-文件管理"><a href="#2-文件管理" class="headerlink" title="2. 文件管理"></a>2. 文件管理</h1><h2 id="2-1-ls"><a href="#2-1-ls" class="headerlink" title="2.1 ls"></a>2.1 ls</h2><p>作用：列出所有的文件和目录<br>常用选项：<br>-a 显示所有文件，包括隐藏文件<br>-l 显示详细信息<br>-d 查看目录属性（只查看这个目录，而不查看目录下的文件信息）<br>-h 更友好的显示，例如 ls -lh，文件大小会帮你换算为K<br>-i 查看文件的节点序号（相当于id号，linux中任何文件或目录都有唯一标识的id号，便于系统管理）<br>举例：<br>输入<code>ls -l</code>，结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-rw-rw-r--. 1 zhangchao zhangchao   22 Feb  6 20:17 hh<br></code></pre></td></tr></table></figure><p>依次表示的信息是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">- 开头代表一个文件，d 开头代表是一个目录，l开头代表一个软链接<br>rw-rw-r--. 代表权限信息，<span class="hljs-number">3</span>个一拆分，<span class="hljs-selector-attr">[rw-]</span>、<span class="hljs-selector-attr">[rw-]</span>和<span class="hljs-selector-attr">[r--]</span>，分别是所有者，所属组，其他人的权限<br><span class="hljs-number">1</span> 代表调用次数<br>后面两个用户代表：所有者，所有组<br>文件大小<br>最后一次修改时间/创建时间<br>文件名<br></code></pre></td></tr></table></figure><p>关于linux的权限的小知识：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">u 所有者<br>g 所有组<br>o 其他人<br>r 读<br>w 写<br>x 执行<br><br>-rw-rw-r--. 的意思是<br>-：这是一个文件<br>rw-：它的所有者有读写权限<br>rw-：它的所有组有读写权限<br>r--：其他人有读权限<br></code></pre></td></tr></table></figure><h2 id="2-2-mkdir"><a href="#2-2-mkdir" class="headerlink" title="2.2 mkdir"></a>2.2 mkdir</h2><p>作用：创建一个目录<br>如果我要创建&#x2F;a&#x2F;b&#x2F;c目录，本身a目录是不存在的，即如何递归创建？<br><code>mkdir -p</code>即可递归创建。<br>创建目录可以同时创建多个目录，用空格隔开。</p><p>有关的小命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd 切换到某个目录（基础之基础）<br>pwd 显示当前目录的完整路径（现在cd的是哪个目录？）<br>rmdir 删除空目录（只能删除空目录）<br></code></pre></td></tr></table></figure><h2 id="2-3-cp"><a href="#2-3-cp" class="headerlink" title="2.3 cp"></a>2.3 cp</h2><p>作用：原意copy，即文件的复制。可以复制多个文件，复制的同时可以给文件重命名。<br>用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp [原文件] [新的位置]<br>cp -r 复制目录<br>cp -p 保留原文件的属性<br></code></pre></td></tr></table></figure><h2 id="2-4-mv"><a href="#2-4-mv" class="headerlink" title="2.4 mv"></a>2.4 mv</h2><p>作用：移动&#x2F;剪切文件或目录（不需要加<code>-r</code>），文件的重命名。<br>用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv [原文件] [新的位置]<br>mv [原文件] [新名字]<br></code></pre></td></tr></table></figure><h2 id="2-5-rm"><a href="#2-5-rm" class="headerlink" title="2.5 rm"></a>2.5 rm</h2><p>作用：删除一个文件、目录。<br>用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm [文件]<br>rm -r [目录]<br>-f 强制执行<br>rm -rf [目录] 递归的删除目录和目录里面的所有<br></code></pre></td></tr></table></figure><p>如果一不小心<code>rm -rf /</code>，就gg了。</p><h2 id="2-6-find"><a href="#2-6-find" class="headerlink" title="2.6 find"></a>2.6 find</h2><p>文件搜索命令（windows下文件搜索工具everything）<br>基本语法：<code>find [搜索范围] [匹配条件]</code><br><code>find /home -name xxx</code>：根据名字搜索<br>如何模糊搜索？利用通配符，*匹配任意字符，?匹配单个字符，举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /home -name *xxx*  （查找多个值需要&quot;*xxx*&quot;，双引号引起来）<br></code></pre></td></tr></table></figure><p><code>find /home -iname xxx</code>：不区分大小写搜索<br>如何按文件大小来筛选？（+代表大于，-代表小于，否则等于），举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /home -size +204800  （查找大于100MB的数据，注意数据格式为数据块，1数据块=512B=0.5KB）<br></code></pre></td></tr></table></figure><p><code>find /home -user zhangchao</code>：按用户来查找，同理用户组为<code>-group</code></p><h3 id="2-6-1-高级查找"><a href="#2-6-1-高级查找" class="headerlink" title="2.6.1 高级查找"></a>2.6.1 高级查找</h3><p><code>find /home -cmin -5</code>：在home目录下查找5分钟内被修改过属性的文件和目录，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-amin 访问时间<br>-cmin 文件属性<br>-mmin 文件内容<br></code></pre></td></tr></table></figure><p><code>find /home -size +163840 -a -size -204800</code>：查找文件大于80MB小于100MB的文件，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-a 表示两个条件同时满足，记作and<br>-o 表示满足任意一个条件即可，记作or<br></code></pre></td></tr></table></figure><p>如何根据类型查找？<br><code>-type</code>根据文件类型查找，其中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">f：文件<br>d：目录<br>l：软链接<br></code></pre></td></tr></table></figure><p>如何对查找出来的结果做进一步的操作？<br><code>find /home -name xxx -exec ls -l &#123;&#125; \;</code>：对查找出来的结果进行批量的ls -l操作，其中后面的<code>[-exec ls -l &#123;&#125; \;]</code>是一个固定的格式<code>-exec</code>可以用<code>-ok</code>代替，只是每个文件都要询问一下。<br>根据i节点查找？举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">找到当前目录下，i节点为12345的文件并删掉它<br>find . -inum 12345 -exec rm &#123;&#125; \;<br></code></pre></td></tr></table></figure><h2 id="2-7-locate"><a href="#2-7-locate" class="headerlink" title="2.7 locate"></a>2.7 locate</h2><p><code>find</code>命令需要遍历查找文件夹，浪费大量资源，如何高效查找？<br><code>locate</code>命令在文件库中查找文件，不在硬盘中查找，所以速度很快，语法<code>locate [文件名]</code><br>如果一个文件新建不久，资料库中没有，就无法找到<br>可以使用命令<code>updatedb</code>更新资料库，<code>不会</code>更新系统的<code>/tmp</code>文件夹中的内容<br><code>locate -i [文件名]</code>：不区分大小写的搜寻</p><h2 id="2-8-which"><a href="#2-8-which" class="headerlink" title="2.8 which"></a>2.8 which</h2><p>特殊查找，查找命令在哪个文件夹。<br>语法：<code>which [命令名]</code><br>例如：<code>which ls</code><br>除了显示命令的地址所在，还可以显示命令的别名。例如普通的<code>ls</code>可以显示文件、文件夹的颜色，其实<code>ls</code>是<code>ls --color</code>的别名，如果要执行底层的<code>ls</code>，可以用<code>\ls</code></p><h2 id="2-9-whereis"><a href="#2-9-whereis" class="headerlink" title="2.9 whereis"></a>2.9 whereis</h2><p>语法：<code>whereis [命令名]</code><br>和<code>which</code>功能一样，<code>whereis</code>还可以查到该命令的帮助文档所在地址</p><h2 id="2-10-grep"><a href="#2-10-grep" class="headerlink" title="2.10 grep"></a>2.10 grep</h2><p>查找某个确定文件中是否有某某关键字。<br>语法：<code>grep [指定匹配字符串] [文件名]</code>，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-i：不区分大小写<br>-v：排除指定字符串<br></code></pre></td></tr></table></figure><p>例：<br><code>grep -v ^# /xxx.txt</code>：排除#开头的内容</p><h2 id="2-11-man"><a href="#2-11-man" class="headerlink" title="2.11 man"></a>2.11 man</h2><p>查看指定命令的帮助手册<br>语法：<code>man [命令名]</code><br>例如：<code>man ls</code><br>如果直接查看配置文件信息，可以<code>man [配置文件名]</code><br>例如：<code>man services</code></p><blockquote><p>小知识，帮助文档的<code>文件名</code>中含有<code>1</code>代表命令的帮助，<code>5</code>代表配置文件的帮助</p></blockquote><p>其他查看帮助信息的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">whatis [命令名]<br>apropos [配置文件名]<br></code></pre></td></tr></table></figure><p>还有命令加上 –help，查看帮助<br>例如<code>ls --help</code><br>注意：内置shell命令（例如<code>cd</code>）无法<code>man</code>，<code>which</code>等，这时查看帮助可以用<code>help [命令名]</code><br>例如：<code>help cd</code></p><h2 id="2-12-压缩-amp-解压"><a href="#2-12-压缩-amp-解压" class="headerlink" title="2.12 压缩&amp;解压"></a>2.12 压缩&amp;解压</h2><h3 id="2-12-1-gzip"><a href="#2-12-1-gzip" class="headerlink" title="2.12.1 gzip"></a>2.12.1 gzip</h3><p>压缩成<code>.gz</code>格式的压缩包<br>语法：<code>gzip [文件名]</code>，生成<code>.gz</code>压缩文件<br>解压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gunzip [压缩文件]<br>gzip -d [压缩文件]<br></code></pre></td></tr></table></figure><p>这种方法压缩，解压后，<code>不保留原文件</code>；<code>只能压缩文件，不能压缩目录</code></p><h3 id="2-12-2-tar"><a href="#2-12-2-tar" class="headerlink" title="2.12.2 tar"></a>2.12.2 tar</h3><p>另一种方法打包压缩<br>语法：<code>tar [选项] [压缩后文件名] [目录]</code>，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">-c 打包<br>-v 显示详细信息<br>-f 指定文件名<br>-z 打包的同时压缩/解压缩<br>-x 解压缩<br></code></pre></td></tr></table></figure><p>例如：<br><code>tar -cvf subtemp.tar subtemp</code>：仅打包<br><code>tar -cvzf subtemp.tar.gz subtemp</code>：打包并压缩，这个是最常见的压缩包<code>.tar.gz</code><br>解压时候把<code>-c</code>换成<code>-x</code>即可<br>注意<code>f</code>字母要写在最后，不能<code>-zcfv</code>等，<code>z</code>跟gz压缩格式有关</p><h3 id="2-12-3-zip"><a href="#2-12-3-zip" class="headerlink" title="2.12.3 zip"></a>2.12.3 zip</h3><p>语法：<code>zip [选项] [压缩后文件名] [文件或目录]</code>，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-r：压缩目录<br></code></pre></td></tr></table></figure><p>解压：<code>unzip [压缩文件名]</code></p><h3 id="2-12-4-bzip2"><a href="#2-12-4-bzip2" class="headerlink" title="2.12.4 bzip2"></a>2.12.4 bzip2</h3><p>gzip的升级版，bzip2<br>语法：<code>bzip2 [选项] [文件]</code>，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-k：产生压缩文件后保留原文件<br></code></pre></td></tr></table></figure><p>跟tar一起使用<br><code>tar -cvjf subtemp.tar.bz2 subtemp</code>：打包并压缩<br>把<code>z</code>换成<code>j</code>压缩成<code>.bz2</code>格式的压缩包，解压同理<code>-c</code>换成<code>-x</code><br>解压缩：<br>语法：<code>bunzip2 [压缩文件名]</code></p><p>总结一下（文件后缀只是方便人区分，linux系统不认后缀的）：</p><ol><li><code>.gz</code>是<code>gzip</code>命令压缩产生的，这个只能压缩单个文件</li><li><code>.tar</code>是<code>tar</code>命令产生的，可以打包多个文件，文件夹</li><li><code>.zip</code>是<code>zip</code>命令，其余同<code>tar</code></li><li><code>.bz2</code>是<code>gzip</code>的升级版，除了能加<code>-k</code>参数保留原文件以外，其它没功能加强</li></ol><h1 id="3-文件浏览编辑"><a href="#3-文件浏览编辑" class="headerlink" title="3. 文件浏览编辑"></a>3. 文件浏览编辑</h1><h2 id="3-1-touch"><a href="#3-1-touch" class="headerlink" title="3.1 touch"></a>3.1 touch</h2><p>创建一个文件，关于带空格的文件名，不建议创建<br>如果文件名必须带空格，可以用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch &quot;pro files&quot;<br></code></pre></td></tr></table></figure><p>用双引号包含。所有命令中对带空格的文件名，都必须用双引号括住</p><h2 id="3-2-cat"><a href="#3-2-cat" class="headerlink" title="3.2 cat"></a>3.2 cat</h2><p><code>cat [文件名]</code>：查看文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat -n：查看行号<br></code></pre></td></tr></table></figure><h2 id="3-3-tac"><a href="#3-3-tac" class="headerlink" title="3.3 tac"></a>3.3 tac</h2><p><code>tac [文件名]</code>：倒着查看文件</p><h2 id="3-4-more"><a href="#3-4-more" class="headerlink" title="3.4 more"></a>3.4 more</h2><p>如何浏览大文件？<br><code>more [文件名]</code>：浏览大文件（分页）<br>技巧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">空格，f：翻页查看（下一页）<br>回车：一行一行查看<br>q：退出浏览<br></code></pre></td></tr></table></figure><h2 id="3-5-less"><a href="#3-5-less" class="headerlink" title="3.5 less"></a>3.5 less</h2><p>相比more，如何搜索，向上翻页？<br><code>less [文件名]</code>：分页查看大文件<br>在more命令的基础上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">PgUp向上翻页<br>/搜索关键字，按键n，跳至下一个关键字<br></code></pre></td></tr></table></figure><h2 id="3-6-head"><a href="#3-6-head" class="headerlink" title="3.6 head"></a>3.6 head</h2><p>只想看前几行？<br><code>head -n xx [文件名]</code><br>默认显示前10行</p><p>反之，想看后几行？<br><code>tail -n xx [文件名]</code><br>默认10行<br><code>tail -f</code>可以动态查看</p><h2 id="3-7-链接"><a href="#3-7-链接" class="headerlink" title="3.7 链接"></a>3.7 链接</h2><p>软链接：<code>ln -s [原文件] [链接文件]</code><br>硬链接：<code>ln [原文件] [链接文件]</code><br>软链接相当于原文件的快捷方式。权限都是rwx。<br>硬链接相当于原文件的拷贝，但是这两个文件可以同步更新，且这两个文件的i节点相同。硬链接不能跨分区生成</p><h2 id="3-8-vim"><a href="#3-8-vim" class="headerlink" title="3.8 vim"></a>3.8 vim</h2><p>强大的文本编辑器<br>语法：<code>vim [文件名]</code><br>编辑模式：<code>i，a，o，I，A，O</code>，退出编辑模式按<code>Esc</code><br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653667843601-fe8cdb99-f3dd-4620-b6a2-94489cbee3a3.png#clientId=uadd86808-607a-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ub4e0530a&margin=%5Bobject%20Object%5D&name=linux_vim1.PNG&originHeight=261&originWidth=300&originalType=binary&ratio=1&rotation=0&showTitle=false&size=46549&status=done&style=none&taskId=u2dca43c0-6b6e-4eae-8e3e-9c44b908efa&title=" alt="linux_vim1.PNG"><br>命令模式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">:set nu 设置行号<br>:set nonu 取消行号<br>gg 第一行<br>G 最后一行<br>nG 到第n行<br>:n 到第n行<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">移至行尾</span><br>0 移至行首<br></code></pre></td></tr></table></figure><p>复制剪切操作：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653667870177-376aff1b-03ed-4463-a9ec-37046323f539.png#clientId=uadd86808-607a-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u1948f644&margin=%5Bobject%20Object%5D&name=linux_vim2.PNG&originHeight=217&originWidth=300&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40708&status=done&style=none&taskId=u1d819c60-2a89-41b9-99a1-55080f3af6a&title=" alt="linux_vim2.PNG"><br>删除操作：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653667890047-2fdce277-ad26-405a-9719-f7a0c2d540d8.png#clientId=uadd86808-607a-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9328d556&margin=%5Bobject%20Object%5D&name=linux_vim3.PNG&originHeight=203&originWidth=300&originalType=binary&ratio=1&rotation=0&showTitle=false&size=41090&status=done&style=none&taskId=u105ceef5-c654-4df6-bb20-4fffb35e026&title=" alt="linux_vim3.PNG"><br>替换字符和取消操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">r：替换光标所在的字符<br>R：从光标处开始替换字符，按[Esc]结束<br>u：取消上一步的操作<br></code></pre></td></tr></table></figure><p>搜索和less，more一样：按&#x2F;来搜索，n切换下一个结果，搜索时忽略大小写：<code>:set ic</code><br>替换字符串：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">:%s/oldstr/newstr/g：全文替换<br>:n1,n2s/oldstr/newstr/g：在指定范围内替换<br></code></pre></td></tr></table></figure><p>最后退出vim：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">:w 保存修改<br>:w new_file 另存为指定文件<br>:wq 保存修改并退出<br>:q! 不保存修改退出<br>ZZ 快捷键退出，相当于wq了<br></code></pre></td></tr></table></figure><p>高级vim操作，技巧：<br><code>:r [文件名]</code>：导入其它文件到当前光标处<br><code>:![命令名]</code>：在不退出vim的情况下执行命令<br><code>:r ![命令名]</code>：将执行命令的结果导入当前光标处<br><code>:n1,n2s/^/#/g</code>：连续注释行<br><code>:n1,n2s/^#/ /g</code>：把连续注释的行去掉<br><code>:ab mymail xxxx@abc.com</code>：替换，这样的话，在vim编辑中，只要输入mymail后，都会被替换成指定值</p><h1 id="4-权限管理"><a href="#4-权限管理" class="headerlink" title="4. 权限管理"></a>4. 权限管理</h1><p>介绍一下linux中关于权限的操作。在文件管理中谈到，linux权限人分为：所有者，所属组和其他人，对文件的操作分为<code>r</code>读权限，<code>w</code>写权限和<code>x</code>执行权限，这节细说权限和讲如何更改权限。<br>截一张图细说<code>rwx</code>区别：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653668109789-a3878d43-280a-4d16-808f-4da9de6a96ee.png#clientId=uadd86808-607a-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u46eaf1ba&margin=%5Bobject%20Object%5D&name=linux_rwx.PNG&originHeight=307&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77719&status=done&style=none&taskId=u6f352305-17f4-45d7-ab6a-12ac228cff1&title=" alt="linux_rwx.PNG"><br>注意：删除一个文件不需要对此文件有写权限，只需要有对该文件所在的目录有写权限即可</p><h2 id="4-1-chmod"><a href="#4-1-chmod" class="headerlink" title="4.1 chmod"></a>4.1 chmod</h2><p><code>chmod [&#123;ugoa&#125;&#123;+-=&#125;&#123;rwx&#125;] [文件或目录]</code>：改变文件或目录权限<br>-R 递归修改</p><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">//所有者加上执行权限<br>chmod u+x xxx.txt<br>//所有组加上写权限，其他人减去读权限<br>chmod g+w,o-r xxx.txt<br>//所有组的权限等于rwx<br>chmod g=rwx xxx.txt<br></code></pre></td></tr></table></figure><p>另一种数字的表示方法：<br>r —- 4<br>w —- 2<br>x —- 1</p><p>相互转化：<br>532 &#x3D;&gt; r-x-wx-w-<br>5代表u权限<br>3代表g权限<br>2代表o权限</p><h2 id="4-2-useradd"><a href="#4-2-useradd" class="headerlink" title="4.2 useradd"></a>4.2 useradd</h2><p><code>useradd xxx</code>：创建用户<br><code>passwd xxx</code>：更改用户密码<br><code>groupadd xxx</code>：创建用户组</p><h2 id="4-3-chown"><a href="#4-3-chown" class="headerlink" title="4.3 chown"></a>4.3 chown</h2><p><code>chown [用户] [文件或目录]</code>：改变文件的所有者，只有管理员root才能执行<br><code>chgrp [用户组] [文件或目录]</code>：改变文件的所属组</p><h2 id="4-4-umask"><a href="#4-4-umask" class="headerlink" title="4.4 umask"></a>4.4 umask</h2><p>如何更改创建文件或文件夹时的默认权限？<br><code>umask -S</code>：查看默认权限</p><p>注意：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">直接umask显示0022，实际权限计算：首字母0不算，777-022=755就是实际表示的权限<br></code></pre></td></tr></table></figure><p><code>umask 023</code>：更改默认权限为777-023&#x3D;754</p><h1 id="5-软件包管理"><a href="#5-软件包管理" class="headerlink" title="5. 软件包管理"></a>5. 软件包管理</h1><p>软件包分为：</p><ol><li>源代码包</li><li>二进制包（RPM包、系统默认包）</li></ol><h2 id="5-1-rpm"><a href="#5-1-rpm" class="headerlink" title="5.1 rpm"></a>5.1 rpm</h2><p>RPM包的依赖性查询：<code>www.rpmfind.net</code><br>手动安装rpm包的最大坏处：<br>一个包的依赖太多，a-&gt;b-&gt;c树形依赖，或者a-&gt;b-&gt;c-&gt;a环形依赖，使得安装rpm包变得很复杂<br>RPM安装：<br>语法：<code>rpm -ivh [包全名]</code>，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-i（install）：安装<br>-v（verbose）：显示详细信息<br>-h（hash）：显示进度<br>--nodeps：不检测依赖性<br></code></pre></td></tr></table></figure><p>RPM包升级：<br>语法：<code>rpm -Uvh [包全名]</code>，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-U：升级<br></code></pre></td></tr></table></figure><p>RPM包卸载：<br>语法：<code>rpm -e [包名]</code> （这个是包名而不是全名）</p><p>RPM包查询：</p><ol><li>查询是否安装：<code>rpm -q [包名]</code></li><li>查询所有已经安装的RPM包<code>rpm -qa</code>，只看所有包中关于<code>httpd</code>的包：<code>rpm -qa | grep httpd</code></li><li>查询软件包详细信息：<code>rpm -qi [包名]</code>，<code>-i</code>：查询软件信息，<code>-p</code>：查询未安装包信息（指定包全名）</li><li>查询包中文件安装位置：<code>rpm -ql [包名]</code></li><li>查询系统文件属于哪个RPM包：<code>rpm -qf [系统文件名]</code></li><li>查询软件包的依赖性：<code>rpm -qR [包名]</code></li></ol><p>RPM包校验：<br>语法：<code>rmp -V [包名]</code><br>如果没有任何提示，说明这个包自安装以来就没被修改过：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653668377006-79e66d66-c19f-47f9-8084-410c6b2a4291.png#clientId=uadd86808-607a-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ub4da80d1&margin=%5Bobject%20Object%5D&name=linux_rpm1.PNG&originHeight=281&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=100679&status=done&style=none&taskId=ueae31618-0bbe-4f8f-b9f0-c3b65959fab&title=" alt="linux_rpm1.PNG"><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653668376979-16ec20c9-ff08-4879-9aa1-5e6e0c7ef8d1.png#clientId=uadd86808-607a-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc0d50775&margin=%5Bobject%20Object%5D&name=linux_rpm2.PNG&originHeight=205&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57191&status=done&style=none&taskId=ub067a614-c1b1-40e4-a26d-36adbab4b90&title=" alt="linux_rpm2.PNG"></p><h2 id="5-2-yum"><a href="#5-2-yum" class="headerlink" title="5.2 yum"></a>5.2 yum</h2><p>为了解决rpm包的层层安装，解决依赖性问题，推荐使用<code>yum</code>直接安装</p><p>yum源：<br><code>vim /etc/yum.repos.d/CentOS-Base.repo</code>：打开默认的配置文件<br><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653668440368-ec197b40-d89e-487f-9710-f4caa281d482.png#clientId=uadd86808-607a-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u115aa04c&margin=%5Bobject%20Object%5D&name=linux_yum.PNG&originHeight=224&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=99043&status=done&style=none&taskId=ued1cc0fd-3a26-4271-909e-7d9e1a33617&title=" alt="linux_yum.PNG"><br>常用的yum命令：<br><code>yum list</code>：查询所有可用的软件包列表<br><code>yum search [包名]</code>：搜索服务器上所有和关键字相关的包<br><code>yum -y install [包名]</code>：安装软件包<br><code>-y</code>：自动回答yes</p><p>升级软件包（如果不加包名会升级所有软件包，包括linux内核，会导致服务器崩溃，慎用）：<br><code>yum -y update [包名]</code></p><p>卸载软件包（和升级一样，小心使用，一定要写包名；慎用，卸载可能删掉某些公用包导致其它软件无法正常使用）：<br><code>yum -y remove [包名]</code><br><code>yum grouplist</code>：列出所有可用的软件组<br><code>yum groupinstall [软件组名]</code>：安装软件组<br><code>yum groupremove [软件组名]</code>：卸载指定软件组</p><h2 id="5-3-安装源码包"><a href="#5-3-安装源码包" class="headerlink" title="5.3 安装源码包"></a>5.3 安装源码包</h2><p>源码包保存位置：<code>/usr/local/src</code><br>软件安装位置：<code>/usr/local/</code></p><p>查看这个文件夹占用多大空间<br><code>du -sh [目录名]</code></p><p>安装源码包步骤（以安装apache为例）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">准备：下载源码包，解压，进入解压目录（INSTALL文件有安装步骤和提示）<br>命令：<br>./configure --prefix=/usr/local/apache2（定义安装目录）<br>作用：<br>1.定义需要的功能选项<br>2.检测环境是否符合安装需求<br>3.把定义好的功能选项和信息写入Makefile文件，用于后续的编译<br></code></pre></td></tr></table></figure><p>然后执行<code>make</code>命令编译（前提linux已安装<code>gcc</code>，如果make失败可以用<code>make clean</code>来清除编译产生的临时数据）<br>最后<code>make install</code>编译安装<br>源码包的卸载直接删除安装后的文件夹即可，例如直接<code>rm -rf /usr/local/apache2</code>就可以完成卸载<br>有的软件包有自动安装脚本，直接运行<code>./setup.sh</code>即可完成安装<br>如果是下载的已经编译好的二进制文件，只需要解压后即可使用。例如java环境等，但为了方便操作，一般需要配置环境变量或者生成软连接到<code>/usr/local/bin/</code>目录下</p><h3 id="5-3-1-启动服务"><a href="#5-3-1-启动服务" class="headerlink" title="5.3.1 启动服务"></a>5.3.1 启动服务</h3><p>语法：<code>[绝对路径] start</code><br>例如<code>/etc/rc.d/init.d/httpd start</code>，这种启动方式适用于自己手动安装的软件包<br>另一种启动方式：<code>service httpd start</code>，适用于用rpm包安装的软件和yum安装的软件</p><h1 id="6-网络管理"><a href="#6-网络管理" class="headerlink" title="6. 网络管理"></a>6. 网络管理</h1><h2 id="6-1-who"><a href="#6-1-who" class="headerlink" title="6.1 who"></a>6.1 who</h2><p>查看用户的登录信息</p><h2 id="6-2-w"><a href="#6-2-w" class="headerlink" title="6.2 w"></a>6.2 w</h2><p>和<code>who</code>一样，显示结果中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">tty：代表本地登录<br>pts：代表远程终端登录<br></code></pre></td></tr></table></figure><h2 id="6-3-write"><a href="#6-3-write" class="headerlink" title="6.3 write"></a>6.3 write</h2><p>简单的即时通信，给用户发信息，以<code>Ctrl+D</code>保存结束<br><code>write [用户名]</code>：用户不在登录状态是收不到的，可以用<code>w</code>命令，看看哪些用户在登录状态</p><h2 id="6-4-wall"><a href="#6-4-wall" class="headerlink" title="6.4 wall"></a>6.4 wall</h2><p>如何群发登录用户？<br><code>wall [消息内容]</code>：所有的登录用户都可以收到</p><h2 id="6-5-ping"><a href="#6-5-ping" class="headerlink" title="6.5 ping"></a>6.5 ping</h2><p>探测消息，网络是否通？<br>语法：<code>ping [选项] [IP地址]</code>，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-c：指定发送次数<br></code></pre></td></tr></table></figure><p>例如：<code>ping -c3 127.0.0.1</code></p><h2 id="6-6-ifconfig"><a href="#6-6-ifconfig" class="headerlink" title="6.6 ifconfig"></a>6.6 ifconfig</h2><p>查看网卡信息，windows里面叫<code>ipconfig</code>，eth0代表本地的真实网卡，主要是查看机器的IP地址</p><h2 id="6-7-mail"><a href="#6-7-mail" class="headerlink" title="6.7 mail"></a>6.7 mail</h2><p>邮件命令，向某一个用户发送邮件<br>语法：<code>mail [用户名]</code><br>查看邮件：<br>mail即可，help查看支持的命令格式，输入数字代表查看第几封邮件，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">h：列出所有邮件<br>d [数字]：删除某封邮件<br>q：退出<br></code></pre></td></tr></table></figure><h2 id="6-8-last"><a href="#6-8-last" class="headerlink" title="6.8 last"></a>6.8 last</h2><p>列出目前与过去用户登入系统的信息，重启系统信息等</p><h2 id="6-9-lastlog"><a href="#6-9-lastlog" class="headerlink" title="6.9 lastlog"></a>6.9 lastlog</h2><p>列出用户最后一次登录系统的信息</p><h2 id="6-10-traceroute"><a href="#6-10-traceroute" class="headerlink" title="6.10 traceroute"></a>6.10 traceroute</h2><p><code>非常重要</code>的一个命令，显示数据包到主机间的路径<br>例如：<code>traceroute www.baidu.com</code><br>如果网断了，可以用这个命令查看在哪一个IP节点丢包的</p><h2 id="6-11-netstat"><a href="#6-11-netstat" class="headerlink" title="6.11 netstat"></a>6.11 netstat</h2><p>显示网络相关信息<br>语法：<code>netstat [选项]</code>，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">-t：TCP协议<br>-u：UDP协议<br>-l：监听<br>-r：路由<br>-n：显示IP地址和端口号<br></code></pre></td></tr></table></figure><p>例子：<br><code>netstat -tlun</code>：查看本机监听的端口（可以查看本机开了哪些服务）<br><code>netstat -an</code>：查看本机所有的网络连接<br><code>netstat -rm</code>：查看本机路由表（查询本机网关）</p><h2 id="6-12-setup"><a href="#6-12-setup" class="headerlink" title="6.12 setup"></a>6.12 setup</h2><p>调出详细配置页面（红帽系列的系统才有这个命令）<br>配置完后重启网络服务：<code>service network restart</code></p><h2 id="6-13-mount"><a href="#6-13-mount" class="headerlink" title="6.13 mount"></a>6.13 mount</h2><p>挂载光盘，卸载光盘<br>语法：<code>mount [-t iso9660] [设备文件名] [挂载点]</code><br>例子（&#x2F;dev是放设备的目录，&#x2F;mnt是挂载目录，在里面新建一个自己的挂载点）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -t iso9660 /dev/sr0 /mnt/cdrom<br>mount /dev/sr0 /mnt/cdrom，也行<br></code></pre></td></tr></table></figure><p>卸载光盘：<code>unmount /dev/sr0</code>，或者<code>unmount /mnt/cdrom</code><br>注意卸载时当前目录不能为挂载目录，否则会提示busy</p><h2 id="6-14-shutdown"><a href="#6-14-shutdown" class="headerlink" title="6.14 shutdown"></a>6.14 shutdown</h2><p>关机重启命令（推荐shutdown，安全性高）<br>语法：<code>shutdown [选项] [时间]</code>，参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">-c：取消前一个关机命令<br>-h：关机<br>-r：重启<br></code></pre></td></tr></table></figure><p>其它关机命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">halt<br>poweroff<br>init 0<br>其它重启命令<br>reboot<br>init 6<br></code></pre></td></tr></table></figure><p>启动选项，打开配置文件<code>cat /etc/inittab</code>，小知识：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">0：关机<br>1：单用户<br>2：不完全多用户，不含NFS文件共享服务<br>3：完全多用户（一般服务器是这个）<br>4：未分配<br>5：图形界面（一般个人机，虚拟机）<br>6：重启<br></code></pre></td></tr></table></figure><h2 id="6-15-runlevel"><a href="#6-15-runlevel" class="headerlink" title="6.15 runlevel"></a>6.15 runlevel</h2><p>查询当前运行级别</p><h2 id="6-16-logout"><a href="#6-16-logout" class="headerlink" title="6.16 logout"></a>6.16 logout</h2><p>退出登录命令（操作完服务器记得退出）</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30分钟搭建个人博客</title>
    <link href="/2017/07/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/30%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2017/07/28/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/30%E5%88%86%E9%92%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><p><a name="ctaL4"></a></p><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>一个不需要购买服务器的博客网站：Hexo<br />基础：</p><ol><li>玩过 github，至少上传过一个自己的项目&#x2F;工程</li><li>有一定的 node.js 基础，至少安装过 node 环境，了解 npm 命令<br><a name="XHqcf"></a></li></ol><h1 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2. 环境准备"></a>2. 环境准备</h1><p><a name="UUPjm"></a></p><h2 id="2-1-NodeJs"><a href="#2-1-NodeJs" class="headerlink" title="2.1 NodeJs"></a>2.1 NodeJs</h2><p><a href="http://nodejs.cn/">官方网站</a>，下载安装即可<br />常用的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看是否安装好了，查看版本信息</span><br>node -v<br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地安装依赖</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装到项目的 node_modules 文件夹中，具体依赖会写到 package.json 中</span><br>npm install xxx --save<br><span class="hljs-meta prompt_"># </span><span class="language-bash">所有的依赖包从 package.json 中读取并安装好，自动生成 node_modules 文件夹</span><br>npm install<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装一个依赖（全局）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个包会安装到`C:\Users\xx\AppData\Roaming\npm\node_modules`中，对所有的node项目都有效</span><br>npm install xxx -g<br></code></pre></td></tr></table></figure><p>为了安装依赖更快，设置仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config set registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>此后会发现 <code>C:\Users\xxx</code>（本人Win10）多了 <code>.npmrc</code>文件，这就是你的 npm 配置文件<br><a name="ku79W"></a></p><h2 id="2-2-Git"><a href="#2-2-Git" class="headerlink" title="2.2 Git"></a>2.2 Git</h2><p><a href="https://git-scm.com/">官方网站</a><br /><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896067074338496">安装教程</a><br />设置个人信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global user.name &quot;Your Name&quot;<br>git config --global user.email &quot;email@example.com&quot;<br></code></pre></td></tr></table></figure><p>生成公钥：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">执行命令，一直按回车，生成公钥</span><br>ssh-keygen -t rsa -C &quot;邮箱地址&quot;<br></code></pre></td></tr></table></figure><p>生成后查看目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">C:\Users\&#123;你的电脑&#125;\.ssh<br></code></pre></td></tr></table></figure><p>有 id_rsa、id_rsa.pub 文件。<code>C:\Users\&#123;你的电脑&#125;</code>目录下有 <code>.gitconfig</code>配置文件<br />需要将公钥拷贝到你的 github 上，否则无法上传项目<br><a name="DHaDF"></a></p><h1 id="3-开始安装"><a href="#3-开始安装" class="headerlink" title="3. 开始安装"></a>3. 开始安装</h1><p><a name="o37GZ"></a></p><h2 id="3-1-生成博客项目"><a href="#3-1-生成博客项目" class="headerlink" title="3.1 生成博客项目"></a>3.1 生成博客项目</h2><ol><li><p>全局安装 Hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install -g hexo<br></code></pre></td></tr></table></figure></li><li><p>进入一个空文件夹，初始化项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br></code></pre></td></tr></table></figure><p>可以看到你的博客项目了</p></li><li><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化所有依赖</span><br>npm install<br><span class="hljs-meta prompt_"># </span><span class="language-bash">没有这个依赖无法推送博客到 github，需要安装</span><br>npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><p>本地跑起来看看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">生成静态文件</span><br>hexo generate<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动本地服务</span><br>hexo server<br></code></pre></td></tr></table></figure><p>在浏览器中输入 localhost:4000 就可以看到本地的博客了</p></li><li><p>把个人博客推送到 github 上，让其他人访问</p></li></ol><p>在自己的 github 上新建仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zhang0chao0.github.io  // zhang0chao0 换成 yourname<br></code></pre></td></tr></table></figure><p>编辑博客配置文件，在你的 Hexo 根目录下有一个 _config_yml 文件，就是站点的配置文件，在最后加上：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:zhang0chao0/zhang0chao0.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>zhang0chao0 换成 yourname 即可<br />开始上传博客：<br />在hexo根目录下，用指令发布：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo deploy</span><br></code></pre></td></tr></table></figure><p>在浏览器输入：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">yourname.github.<span class="hljs-built_in">io</span><br></code></pre></td></tr></table></figure><p>就能看到你自己的的博客了<br><a name="xDa3y"></a></p><h2 id="3-2-开始写第一篇文章"><a href="#3-2-开始写第一篇文章" class="headerlink" title="3.2 开始写第一篇文章"></a>3.2 开始写第一篇文章</h2><p><a href="https://www.zybuluo.com/mdeditor">简单的学习一下MarkDown语法</a></p><ol><li><p>新建第一篇文章</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">&quot;第一篇文章&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到<code>source/_posts</code>目录下已经有了 md 文件<br />给文档归类和增加标签：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">第一篇文章</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2017-07-26 10:02:58</span><br><span class="hljs-attr">categories:</span> <span class="hljs-string">Java</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Think</span> <span class="hljs-string">in</span> <span class="hljs-string">Java</span>]<br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure></li><li><p>发表自己的文章到 github</p></li></ol><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">先清空上次生成的静态文件</span><br>hexo clean<br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成新的静态文件</span><br>hexo generate<br><span class="hljs-meta prompt_"># </span><span class="language-bash">推送到 github</span><br>hexo deploy<br></code></pre></td></tr></table></figure><p>发布前想预览下，可以用<code>hexo server</code>在本地预览<br />常用的命名汇总：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new &quot;postName&quot; # 新建文章<br>hexo new page &quot;pageName&quot; # 新建页面<br>hexo generate # 生成静态页面至 public 目录<br>hexo server # 开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）<br>hexo deploy # 将 .deploy 目录部署到 GitHub<br>hexo help  # 查看帮助<br>hexo version  #查看 Hexo 的版本<br></code></pre></td></tr></table></figure><p><a name="Fr5tM"></a></p><h2 id="3-3-让博客更美观"><a href="#3-3-让博客更美观" class="headerlink" title="3.3 让博客更美观"></a>3.3 让博客更美观</h2><p>主题推荐<br><a name="Qnurt"></a></p><h3 id="3-3-1-Hexo-Fluid（正在使用）"><a href="#3-3-1-Hexo-Fluid（正在使用）" class="headerlink" title="3.3.1 Hexo-Fluid（正在使用）"></a>3.3.1 Hexo-Fluid（正在使用）</h3><p><a href="https://hexo.fluid-dev.com/docs/start/">官方用户手册</a><br><a name="MJr7o"></a></p><h3 id="3-3-2-Next"><a href="#3-3-2-Next" class="headerlink" title="3.3.2 Next"></a>3.3.2 Next</h3><p><a href="http://theme-next.iissnan.com/getting-started.html">Next用户手册</a>，一款非常简洁的主题<br /><a href="https://segmentfault.com/a/1190000009544924">好文，让Next主题更炫酷</a><br><a name="oiQWb"></a></p><h2 id="3-4-替换域名"><a href="#3-4-替换域名" class="headerlink" title="3.4 替换域名"></a>3.4 替换域名</h2><p>替换 yourname.github.io 为自己的域名，在有域名的基础上，配置解析规则即可：<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22879930/1653408295492-70f68a4f-003f-40c1-b182-2db814f5256a.png#clientId=u64112c0f-2f74-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u9ff73f18&margin=%5Bobject%20Object%5D&name=zhangchaozc.PNG&originHeight=371&originWidth=1073&originalType=binary&ratio=1&rotation=0&showTitle=false&size=36350&status=done&style=none&taskId=u840c0080-617f-430f-963a-fa0dae64707&title=&width=715.3333333333334" alt="zhangchaozc.PNG"><br />同时在博客项目 <code>source</code>目录下新建文件：CNAMA，内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">zhangchaozc.cn<br></code></pre></td></tr></table></figure><p>重新部署即可<br><a name="s4bup"></a></p><h1 id="4-优化项目"><a href="#4-优化项目" class="headerlink" title="4. 优化项目"></a>4. 优化项目</h1><p><a name="p18Pa"></a></p><h2 id="4-1-访问速度"><a href="#4-1-访问速度" class="headerlink" title="4.1 访问速度"></a>4.1 访问速度</h2><p>Hexo-Fluid 博客中有大量的图片，影响加载，且 github 图片访问速度堪忧<br />图片工具：<a href="https://www.imgurl.org/vip/manage/upload">ImgURL图床</a><br />将图片上传到图床，获取图片链接，进行配置，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">---------------------------</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">首页</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Home Page</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">---------------------------</span><br>index:<br><span class="hljs-meta prompt_">  # </span><span class="language-bash">首页 Banner 头图，可以是相对路径或绝对路径，以下相同</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">Path of Banner image, can be a relative path or an absolute path, the same on other pages</span><br><span class="hljs-meta prompt_">  # </span><span class="language-bash">pic 1</span><br>  banner_img: https://s3.bmp.ovh/imgs/2022/05/24/09aca3dfddf7eb4a.jpg<br></code></pre></td></tr></table></figure><p>替换掉原有的配置</p>]]></content>
    
    
    <categories>
      
      <category>博客搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
